(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{829:function(t,e,a){"use strict";a.r(e);var o=a(13),r=Object(o.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"react如何检查数据和变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react如何检查数据和变化"}},[t._v("#")]),t._v(" React如何检查数据和变化")]),t._v(" "),a("ul",[a("li",[t._v("angular有脏检查机制，Vue通过Object.defineProperty来劫持对象的get、set方法，实现双向绑定")]),t._v(" "),a("li",[t._v("相比较react而言，react是单向数据流动的UI渲染框架，本身不存在数据的检测这一机制，所有的数据改变都是通过setState来手动实现的")]),t._v(" "),a("li",[t._v("React本身不具备数据检查的功能(这个指向双向绑定的特点)，但是在遇到组件更新时会在"),a("code",[t._v("shouldComponentUpdate")]),t._v("这个生命周期函数中进行数据检查相关操作(即本次更新是否返回新的状态)")]),t._v(" "),a("li",[t._v("React响应数据的变化主要是通过生成新的虚拟dom，再将其映射为真实的dom树构建完成来生成新的页面")]),t._v(" "),a("li",[t._v("React的数据是不可变的，通过"),a("code",[t._v("this.setState")]),t._v("或者"),a("code",[t._v("Hook的setState")]),t._v("，生成新的数据而不会去做数据检查")]),t._v(" "),a("li",[t._v("新生成的数据，生成新的虚拟dom，与旧的虚拟dom通过diff算法进行对比，然后确定需要更新的部分")])])])}),[],!1,null,null,null);e.default=r.exports}}]);