(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{825:function(t,a,e){"use strict";e.r(a);var v=e(13),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-分层和合成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-分层和合成"}},[t._v("#")]),t._v(" 1. 分层和合成")]),t._v(" "),e("p",[t._v('​       通常页面的组成是十分复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，以及还有一些比较炫酷的3D动画效果。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种"牵一发而动全身"的绘制策略会严重影响页面的渲染效率。')]),t._v(" "),e("p",[t._v("​       为了提升每帧的渲染效率，Chrome引入了分层和合成的机制")]),t._v(" "),e("p",[t._v("​       你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应着一个图层，Chrome合成器最终将这些图层合成了用于显示页面的图片。如果你比较熟悉PS的话，就很好的理解这个过程，PS中一个项目是由很多图层构成的，每个图层都可以是一张单独的图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。在这个过程中，将素材分解为多个图层操作的就称之为分层，最后将这些图层合并在一起的操作就称为合成。所以，分成和合成通常是一起使用的")]),t._v(" "),e("p",[t._v("​       考虑一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者渐变，这个时候合成器只需要将两个层进行相应的变化操作就可以，显卡处理这些操作驾轻就熟，所以合成时间非常短")]),t._v(" "),e("h2",{attrs:{id:"_2-生成层的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-生成层的方式"}},[t._v("#")]),t._v(" 2. 生成层的方式")]),t._v(" "),e("p",[t._v("在某些特定的条件下，浏览器会主动将渲染层提至合成层，那么影响这个合成因素有哪些？")]),t._v(" "),e("ul",[e("li",[t._v("3D transforms:translate3d,translateZ等")]),t._v(" "),e("li",[t._v("video,canvas,iframe等")]),t._v(" "),e("li",[t._v("通过Element.animate()实现的opacity动画转化")]),t._v(" "),e("li",[t._v("通过CSS动画实现的opacity动画转换")]),t._v(" "),e("li",[t._v("position:fixed")]),t._v(" "),e("li",[t._v("will-change")]),t._v(" "),e("li",[t._v("filter")]),t._v(" "),e("li",[t._v("有合成层后代同时本身overflow不为visible(如果本身是因为明确的定位因素产生的SelfPaintingLayer,则需要z-index不为auto)")])])])}),[],!1,null,null,null);a.default=_.exports}}]);