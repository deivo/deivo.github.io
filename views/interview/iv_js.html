<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>【JavaScript】常见面试汇总 | Deivo</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.png">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="description" content="攻城途中的加特林">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.0c3cfa0f.css" as="style"><link rel="preload" href="/assets/js/app.3f3f190d.js" as="script"><link rel="preload" href="/assets/js/3.8deff83d.js" as="script"><link rel="preload" href="/assets/js/1.000d4abb.js" as="script"><link rel="preload" href="/assets/js/38.fce79e18.js" as="script"><link rel="preload" href="/assets/js/13.8fb5847d.js" as="script"><link rel="prefetch" href="/assets/js/10.d2bcb7cc.js"><link rel="prefetch" href="/assets/js/100.0602b0b9.js"><link rel="prefetch" href="/assets/js/101.3c63d600.js"><link rel="prefetch" href="/assets/js/102.aea40a7a.js"><link rel="prefetch" href="/assets/js/103.458b356f.js"><link rel="prefetch" href="/assets/js/104.a809d21e.js"><link rel="prefetch" href="/assets/js/105.331a080f.js"><link rel="prefetch" href="/assets/js/106.74b77573.js"><link rel="prefetch" href="/assets/js/107.8ba32cca.js"><link rel="prefetch" href="/assets/js/108.4257e88d.js"><link rel="prefetch" href="/assets/js/109.78f070e7.js"><link rel="prefetch" href="/assets/js/11.f4204f7e.js"><link rel="prefetch" href="/assets/js/110.53e92c70.js"><link rel="prefetch" href="/assets/js/111.e27b3af2.js"><link rel="prefetch" href="/assets/js/112.1dfecb56.js"><link rel="prefetch" href="/assets/js/113.7f6df9d0.js"><link rel="prefetch" href="/assets/js/114.def48507.js"><link rel="prefetch" href="/assets/js/115.e8b83696.js"><link rel="prefetch" href="/assets/js/116.f6d18932.js"><link rel="prefetch" href="/assets/js/12.774be810.js"><link rel="prefetch" href="/assets/js/14.f1622930.js"><link rel="prefetch" href="/assets/js/15.f8ea15f7.js"><link rel="prefetch" href="/assets/js/16.0b05affe.js"><link rel="prefetch" href="/assets/js/17.d92b2820.js"><link rel="prefetch" href="/assets/js/18.4b8f938e.js"><link rel="prefetch" href="/assets/js/19.7878e085.js"><link rel="prefetch" href="/assets/js/20.47774679.js"><link rel="prefetch" href="/assets/js/21.cefb1479.js"><link rel="prefetch" href="/assets/js/22.4438d4a3.js"><link rel="prefetch" href="/assets/js/23.7ae2d7a7.js"><link rel="prefetch" href="/assets/js/24.9b560e66.js"><link rel="prefetch" href="/assets/js/25.e6ed784a.js"><link rel="prefetch" href="/assets/js/26.3d2c5f6f.js"><link rel="prefetch" href="/assets/js/27.5fdf9c39.js"><link rel="prefetch" href="/assets/js/28.70e20bc4.js"><link rel="prefetch" href="/assets/js/29.32796178.js"><link rel="prefetch" href="/assets/js/30.a4685975.js"><link rel="prefetch" href="/assets/js/31.13833a84.js"><link rel="prefetch" href="/assets/js/32.7a4f6bc5.js"><link rel="prefetch" href="/assets/js/33.eaa6df1d.js"><link rel="prefetch" href="/assets/js/34.e3b77085.js"><link rel="prefetch" href="/assets/js/35.7b4dd0c5.js"><link rel="prefetch" href="/assets/js/36.ca69860d.js"><link rel="prefetch" href="/assets/js/37.bc0b9d1b.js"><link rel="prefetch" href="/assets/js/39.38f4a0ef.js"><link rel="prefetch" href="/assets/js/4.afd2bdef.js"><link rel="prefetch" href="/assets/js/40.1c77a80e.js"><link rel="prefetch" href="/assets/js/41.38b8cec5.js"><link rel="prefetch" href="/assets/js/42.d825aeb5.js"><link rel="prefetch" href="/assets/js/43.2ac0a6c6.js"><link rel="prefetch" href="/assets/js/44.a4e043e2.js"><link rel="prefetch" href="/assets/js/45.b45b986f.js"><link rel="prefetch" href="/assets/js/46.0fc8a893.js"><link rel="prefetch" href="/assets/js/47.786653ad.js"><link rel="prefetch" href="/assets/js/48.de782698.js"><link rel="prefetch" href="/assets/js/49.6a75e172.js"><link rel="prefetch" href="/assets/js/5.6f549ec8.js"><link rel="prefetch" href="/assets/js/50.9f9048ee.js"><link rel="prefetch" href="/assets/js/51.6547528d.js"><link rel="prefetch" href="/assets/js/52.3b644165.js"><link rel="prefetch" href="/assets/js/53.8e396950.js"><link rel="prefetch" href="/assets/js/54.ddbd29b5.js"><link rel="prefetch" href="/assets/js/55.81de1e1d.js"><link rel="prefetch" href="/assets/js/56.b3c73dc0.js"><link rel="prefetch" href="/assets/js/57.5df97230.js"><link rel="prefetch" href="/assets/js/58.2d2729bd.js"><link rel="prefetch" href="/assets/js/59.6fafdebc.js"><link rel="prefetch" href="/assets/js/6.1abd602b.js"><link rel="prefetch" href="/assets/js/60.62678017.js"><link rel="prefetch" href="/assets/js/61.58ac1358.js"><link rel="prefetch" href="/assets/js/62.e5665491.js"><link rel="prefetch" href="/assets/js/63.96f6b624.js"><link rel="prefetch" href="/assets/js/64.c93d511b.js"><link rel="prefetch" href="/assets/js/65.b028483a.js"><link rel="prefetch" href="/assets/js/66.043b573e.js"><link rel="prefetch" href="/assets/js/67.a7e99637.js"><link rel="prefetch" href="/assets/js/68.1a6a55a6.js"><link rel="prefetch" href="/assets/js/69.70df2a95.js"><link rel="prefetch" href="/assets/js/7.13e754a0.js"><link rel="prefetch" href="/assets/js/70.5eae9921.js"><link rel="prefetch" href="/assets/js/71.58bc5d70.js"><link rel="prefetch" href="/assets/js/72.481e55ba.js"><link rel="prefetch" href="/assets/js/73.4255bcd4.js"><link rel="prefetch" href="/assets/js/74.27626302.js"><link rel="prefetch" href="/assets/js/75.721ee7a5.js"><link rel="prefetch" href="/assets/js/76.46b74716.js"><link rel="prefetch" href="/assets/js/77.98083aae.js"><link rel="prefetch" href="/assets/js/78.82197b88.js"><link rel="prefetch" href="/assets/js/79.3b14ff3f.js"><link rel="prefetch" href="/assets/js/8.79311730.js"><link rel="prefetch" href="/assets/js/80.e55aee62.js"><link rel="prefetch" href="/assets/js/81.f36e5a93.js"><link rel="prefetch" href="/assets/js/82.44f668d7.js"><link rel="prefetch" href="/assets/js/83.cb37ad2f.js"><link rel="prefetch" href="/assets/js/84.f014c0a3.js"><link rel="prefetch" href="/assets/js/85.4a3344ab.js"><link rel="prefetch" href="/assets/js/86.314ac06b.js"><link rel="prefetch" href="/assets/js/87.d058e207.js"><link rel="prefetch" href="/assets/js/88.074a9967.js"><link rel="prefetch" href="/assets/js/89.0c9509c0.js"><link rel="prefetch" href="/assets/js/9.eb8ab02c.js"><link rel="prefetch" href="/assets/js/90.8174bac0.js"><link rel="prefetch" href="/assets/js/91.6789e639.js"><link rel="prefetch" href="/assets/js/92.f5f061c4.js"><link rel="prefetch" href="/assets/js/93.3f871abd.js"><link rel="prefetch" href="/assets/js/94.2d155bc1.js"><link rel="prefetch" href="/assets/js/95.f9af7311.js"><link rel="prefetch" href="/assets/js/96.b112f359.js"><link rel="prefetch" href="/assets/js/97.a4e7c46d.js"><link rel="prefetch" href="/assets/js/98.744a70a4.js"><link rel="prefetch" href="/assets/js/99.1dd22020.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0c3cfa0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" style="max-width:2080px;margin:0 auto;padding:0;" data-v-61e30ce2><div data-v-61e30ce2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-61e30ce2 data-v-61e30ce2><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>Deivo</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>攻城途中的加特林</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>Deivo</span>
            
          <span data-v-25ba6db2>2019 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-61e30ce2><header class="navbar" data-v-61e30ce2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Deivo" class="logo"> <span class="site-name">Deivo</span></a> <div class="links"><!----> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/css/" class="nav-link"><i class="undefined"></i>
  css
</a></li><li class="dropdown-item"><!----> <a href="/categories/FontEnd/" class="nav-link"><i class="undefined"></i>
  FontEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/Interview/" class="nav-link"><i class="undefined"></i>
  Interview
</a></li><li class="dropdown-item"><!----> <a href="/categories/zoom/" class="nav-link"><i class="undefined"></i>
  zoom
</a></li><li class="dropdown-item"><!----> <a href="/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/categories/React/" class="nav-link"><i class="undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/sass/" class="nav-link"><i class="undefined"></i>
  sass
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zoom/" class="nav-link"><i class="undefined"></i>
  Zoom
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/tool/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  工具
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deivo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/Deivo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-61e30ce2></div> <aside class="sidebar" data-v-61e30ce2><div class="personal-info-wrapper" data-v-39576ba9 data-v-61e30ce2><img src="/img/avatar.png" alt="author-avatar" class="personal-img" data-v-39576ba9> <h3 class="name" data-v-39576ba9>
    Deivo
  </h3> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>99</h3> <h6 data-v-39576ba9>Articles</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>17</h3> <h6 data-v-39576ba9>Tags</h6></div></div> <ul class="social-links" data-v-39576ba9><li class="social-item" data-v-39576ba9><i class="iconfont reco-github" style="color:#849b87;" data-v-39576ba9></i></li><li class="social-item" data-v-39576ba9><i class="iconfont reco-gitee" style="color:#fb9b5f;" data-v-39576ba9></i></li></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/css/" class="nav-link"><i class="undefined"></i>
  css
</a></li><li class="dropdown-item"><!----> <a href="/categories/FontEnd/" class="nav-link"><i class="undefined"></i>
  FontEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/Interview/" class="nav-link"><i class="undefined"></i>
  Interview
</a></li><li class="dropdown-item"><!----> <a href="/categories/zoom/" class="nav-link"><i class="undefined"></i>
  zoom
</a></li><li class="dropdown-item"><!----> <a href="/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/categories/React/" class="nav-link"><i class="undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/categories/sass/" class="nav-link"><i class="undefined"></i>
  sass
</a></li><li class="dropdown-item"><!----> <a href="/categories/Vue/" class="nav-link"><i class="undefined"></i>
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/categories/Zoom/" class="nav-link"><i class="undefined"></i>
  Zoom
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/tool/" class="nav-link"><i class="iconfont reco-suggestion"></i>
  工具
</a></div><div class="nav-item"><a href="/about/" class="nav-link"><i class="iconfont reco-account"></i>
  关于我
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/deivo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://gitee.com/Deivo" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-mayun"></i>
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-61e30ce2><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>【JavaScript】常见面试汇总</h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><span data-v-25ba6db2>Deivo</span>
            
          <span data-v-25ba6db2>2019 - </span>
          2022
        </a></span></div></div> <div data-v-61e30ce2><main class="page page-deivo"><section><div class="page-title deivo-title" style="background-image:url(/img/2.jpg);"><h1 class="title">【JavaScript】常见面试汇总</h1> <div data-v-f875f3fc><i class="iconfont reco-account" data-v-f875f3fc><span data-v-f875f3fc>Deivo</span></i> <i class="iconfont reco-date" data-v-f875f3fc><span data-v-f875f3fc>5/1/2020</span></i> <i class="iconfont reco-eye" data-v-f875f3fc><span id="/views/interview/iv_js.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-f875f3fc><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="tags iconfont reco-tag" data-v-f875f3fc><span class="tag-item" data-v-f875f3fc>Interview</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="_1-两个正整数的最大回文产品"><a href="#_1-两个正整数的最大回文产品" class="header-anchor">#</a> 1. 两个正整数的最大回文产品</h2> <p>如<code>x</code>是一个正整数，将 n 的各位数字反向排列所得到的自然数<code>x1</code>和<code>x</code>相等，则<code>x</code>称之为<code>回文数</code></p> <p>例如：有个两个数字 1，11，求两个数字区间的最大回文数就是<code>121</code>，那么<code>121</code>称之为回文数</p> <p>我们可以根据回文数的特点来编写一个方法，实现两个正整数区间的最大回文数，可以能会出现有回文数，或者没有回文数返回<code>NaN</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">isPalindrome</span> <span class="token operator">=</span> <span class="token parameter">number</span> <span class="token operator">=&gt;</span> number <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token operator">...</span>number<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">maxPalindrome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> maxPalindrome <span class="token operator">=</span> <span class="token number">NaN</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> end<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> start<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> current <span class="token operator">=</span> j <span class="token operator">*</span> i
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isNaN</span><span class="token punctuation">(</span>maxPalindrome<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;=</span> maxPalindrome<span class="token punctuation">)</span> <span class="token keyword">break</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> maxPalindrome <span class="token operator">=</span> current
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> maxPalindrome
<span class="token punctuation">}</span>

<span class="token function">maxPalindrome</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">67</span><span class="token punctuation">)</span> <span class="token comment">// 返回结果：4224</span>
</code></pre></div><h2 id="_2-神奇的-null-请输出结果并进行解释"><a href="#_2-神奇的-null-请输出结果并进行解释" class="header-anchor">#</a> 2. 神奇的 null 请输出结果并进行解释</h2> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>输出的结果：[&quot;object&quot;, false]</li> <li>在 MDN 关于 null 的文档中也特别指出来了，typeof null 的结果是 &quot;object&quot;，它是 ECMAScript 的 bug，其实应该是 &quot;null&quot;。但这个 bug 由来已久，在 JavaScript 中已经存在了将近二十年，也许永远不会修复，因为这牵扯到太多的 Web 系统，修复它会产生更多的 bug，令许多系统无法正常工作。而 instanceof 运算符是用来测试一个对象在其原型链构造函数上是否具有 prototype 属性，null 值并不是以 Object 原型建出来的，所以 null instanceof Object 返回 false。</li> <li><code>null</code> 在数学运算中，null 值将被转换为<code>0</code></li> <li><code>null</code>和<code>undefined</code>等值但不全等</li></ul> <h2 id="_3-浏览器的本地存储"><a href="#_3-浏览器的本地存储" class="header-anchor">#</a> 3. 浏览器的本地存储</h2> <h3 id="_3-1-cookie-了解"><a href="#_3-1-cookie-了解" class="header-anchor">#</a> 3.1 cookie 了解</h3> <ul><li>Cookie 最开始被设计出来其实并不是做本地存储的，而是为了弥补 http 在状态管理上的不足</li> <li>http 协议是一个无状态协议，客户端向服务器发请求，服务器返回响应，这次事件就完成了，但是下次发请求如何让服务端直到客户端是谁呢？在这个需求下就产生了 Cookie</li> <li>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面版的 Application 这一栏可以看到)都会携带相同的 Cookie，服务器拿 Cookie 进行解析，便能拿到客户端的状态 Cookie 的作用就是用来做状态存储的，但是也有很多缺陷：<div class="custom-block tip"><p class="title"></p></div></li></ul> <ul><li>1.容量缺陷。Cookie 的体积上限只有 4KB，只能用来存储少量的信息</li> <li>2.性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容</li> <li>3.安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截取，然后进行一系列的篡改，在 Cookie 的有限期内重新发送给服务器，这是很危险的。另外，在 HttpOnly 为 false 的情况下，Cookie 信息能直接通过 js 脚本来读取。
:::</li></ul> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> <strong>应用场景：</strong></h4> <ol><li>购物车功能</li> <li>记住密码，下次自动登录</li> <li>记录用户浏览数据，进行商品（广告）推送</li></ol> <h3 id="_3-2-webstorage-了解"><a href="#_3-2-webstorage-了解" class="header-anchor">#</a> 3.2 WebStorage 了解</h3> <ul><li>WebStorage 又可以分为 localStorage 和 sessionStorage</li></ul> <h4 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> <strong>localStorage</strong></h4> <ul><li><p>和 Cookie 异同：相同的一点是：针对一个域名，即在同一个域名下，会存储相同的一段 localStorage</p></li> <li><p><strong>区别：</strong></p></li></ul> <ol><li>容量：localStorage 的容量上限为 5M，相对于 Cookie 的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的</li> <li>只存在客户端，默认不参与和服务端的通信。这样很好地避免了 Cookie 带来地性能问题和安全问题</li> <li>接口封装。通过 localStorage 暴露在全局，并通过它的 setItem 和 getItem 等方法进行操作，非常方便。</li></ol> <h4 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> <strong>sessionStorage</strong></h4> <ul><li><code>特点：</code>sessionStorage 和 localStorage 是一致的</li> <li><strong>区别：</strong></li></ul> <ol><li>容量。容量上限为 5M</li> <li>只存在客户端，默认不参与和服务端的通信</li> <li>接口封装。除了 sessionStorage 名字有所变化，存储方式、操作方式均和 localStorage 一样</li></ol> <div class="custom-block warning"><p class="title"></p><p>但是 <code>sessionStorage</code> 和 <code>localStorage</code> 有一个本质的区别：前者只是会话级别的存储，并不是持久化存储。会话结束后也就是页面关闭，这部分 sessionStorage 就不存在了</p></div><h4 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> <strong>应用场景：</strong></h4> <ol><li>可以用它对表单信息进行维护，将表单信息存储存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。</li> <li>可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用 <code>sessionStorage</code> 就再合适不过了。事实上微博采取这样的存储方式。</li></ol> <h2 id="_4-防抖节流原理、区别、应用以及实现"><a href="#_4-防抖节流原理、区别、应用以及实现" class="header-anchor">#</a> 4. 防抖节流原理、区别、应用以及实现</h2> <h3 id="防抖"><a href="#防抖" class="header-anchor">#</a> 防抖</h3> <p><strong>原理：</strong> 在时间被触发 n 秒之后再执行回调，如果在这 n 秒内又被触发，则重新计时
<strong>使用场景：</strong></p> <ol><li>按钮提交场景：防止多次提交按钮，只执行最后提交的一次</li> <li>搜索框联想场景：防止联想发送请求，只发送最后一次输入</li></ol> <p><strong>简易版：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
    timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>立即执行版：</strong> 有时候希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token keyword">this</span>；
    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>immediate<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">const</span> callNow<span class="token operator">=</span><span class="token operator">!</span>timeout<span class="token punctuation">;</span>
      timeout<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          timeout<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
      timeout<span class="token operator">=</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>返回值版：</strong> callback 函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout，我们将 callback.apply(context,args)的返回值赋给变量，最后在 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout<span class="token punctuation">,</span> result
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timeout
      timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timeout <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> result <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="节流"><a href="#节流" class="header-anchor">#</a> 节流</h3> <p><strong>原理：</strong> 在时间被触发 n 秒之后再执行回调，如果在这 n 秒内又被触发，则重新计时
<strong>使用场景：</strong></p> <p>节流简称<code>throttle</code>，当持续触发事件时，在到达某个时间段才会触发一次事件</p> <p><strong>使用时间戳：</strong> 使用时间戳，当触发事件发生的时候，我们取出当前的时间戳，然后减去之前的时间戳（最开始设值为 0），如果大于设置的时间周期，就执行函数，然后更新时间戳为当前时间戳，如果小于，就不执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> context<span class="token punctuation">,</span> args
  <span class="token keyword">let</span> previous <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    context <span class="token operator">=</span> <span class="token keyword">this</span>
    args <span class="token operator">=</span> arguments
    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      previous <span class="token operator">=</span> now
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>使用定时器：</strong> 当触发事件的时候，我们设置一个定时器，在触发事件的时候，如果定时器存在，就不执行，知道定时器执行，然后执行函数，清空定时器，这样就可以设置下定时器</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span> <span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timeout <span class="token operator">=</span> <span class="token keyword">null</span>
        <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="防抖和节流区别"><a href="#防抖和节流区别" class="header-anchor">#</a> 防抖和节流区别：</h3> <ul><li>节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数</li></ul> <h2 id="_5-xss-攻击的理解"><a href="#_5-xss-攻击的理解" class="header-anchor">#</a> 5. XSS 攻击的理解</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介：</h3> <p>XSS 全称是 Cross Site Scripting[跨站脚本]，为了和 css 区分，故叫它 xss。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息进行操作。</p> <div class="custom-block tip"><p class="title"></p><ul><li>XSS 攻击主要会完成如下事情：</li></ul> <ol><li>窃取 Cookie</li> <li>监听用户行为，比如输入账号密码后直接发送到黑客服务器</li> <li>修改 DOM 伪造登录表单</li> <li>在页面中生成浮窗广告</li></ol></div><h3 id="分类"><a href="#分类" class="header-anchor">#</a> 分类：</h3> <p>通常情况下，XSS 攻击的实现有三种方式：<strong>存储型</strong>、<strong>反射型</strong>和<strong>文档型</strong></p> <h4 id="_1-存储型"><a href="#_1-存储型" class="header-anchor">#</a> <strong>1. 存储型</strong></h4> <p>存储型，将恶意脚本存储了起来，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果</p> <p>常见的场景是留言评论区提交一段代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行，相当于执行一段位置逻辑的 js 代码，是非常恐怖的。这就是存储型的 xss 攻击</p> <h4 id="_2-反射型"><a href="#_2-反射型" class="header-anchor">#</a> <strong>2. 反射型</strong></h4> <p>反射型 xss 指的是恶意脚本作为网络请求的一部分 比如输入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">http</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>baidu<span class="token punctuation">.</span>com<span class="token operator">?</span>q<span class="token operator">=</span><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;你完蛋了&quot;</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>这样在服务端会拿到 <code>q</code> 参数，然后将内容返回给浏览器端，浏览器将这些内容作为 HTML 的一部分解析，发现是一个脚本，直接执行，这样被攻击了
之所以叫它反射型，是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后在反射到 HTML 文档中，执行解析。和存储型不一样的是：服务器并不会存储这些恶意脚本</li></ul> <h4 id="_3-文档型"><a href="#_3-文档型" class="header-anchor">#</a> <strong>3. 文档型</strong></h4> <p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档，这样的劫持方式包括 <code>wifi 路由劫持</code>或者<code>本地恶意软件</code>等</p> <h3 id="防范措施"><a href="#防范措施" class="header-anchor">#</a> 防范措施：</h3> <p>明白三种 xss 攻击的原理，发现一个共同点：都是让恶意脚本直接能在浏览器中执行，那么要防范它，就是要避免这些脚本代码的执行，为了完成这一点，必须做到<code>一个信念，两个利用</code>。</p> <p><strong>一个信念：</strong></p> <ul><li>千万不要相信任何用户的输入！ 无论是在前端和服务端，都要对用户的输入进行转码或过滤；如</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'你完了！'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>转码后变为：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span>script<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span>你完蛋了<span class="token operator">&amp;</span>#<span class="token number">39</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>lt<span class="token punctuation">;</span><span class="token operator">/</span>script<span class="token operator">&amp;</span>gt<span class="token punctuation">;</span>
</code></pre></div><ul><li>这样的代码在 html 解析的过程中是无法执行的 当然也可以利用关键词过滤的方式，将 script 标签给删除。那么现在的内容只剩下</li></ul> <div class="language-js extra-class"><pre class="language-js"><code></code></pre></div><ul><li>什么都没有。</li></ul> <p><strong>利用 CSP：</strong></p> <ul><li>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能：</li></ul> <ol><li>限制其他域下的资源加载</li> <li>禁止向其他域提交数据</li> <li>提供上报机制，能帮助我们及时发现 XSS 攻击</li></ol> <p><strong>利用 HttpOnly：</strong></p> <ul><li>很多 XSS 攻击脚本都是用来窃取 Cookie，而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值，这样也很好的防范 XSS 攻击。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h3> <ul><li>xss 攻击是指浏览器中执行恶意脚本，然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括：<code>一个信念：</code>不要相信用户的输入，对输入的内容转码或者过滤，让其不可执行；<code>两个利用:</code>利用 CSP,利用 Cookie 的 HttpOnly 属性</li></ul> <h2 id="_6-csrf-攻击"><a href="#_6-csrf-攻击" class="header-anchor">#</a> 6.CSRF 攻击？</h2> <h3 id="简介-2"><a href="#简介-2" class="header-anchor">#</a> 简介：</h3> <ul><li>CSRF(Cross-site request forgery)，即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起的跨站请求。 举个例子，你在某个网站点击了黑客精心挑选的图片，你点击后进入一个新的页面。那么，恭喜你被攻击啦！ 你可能对突然被攻击这件事很好奇，那么接下来就是进行拆解：当你点击了这个链接之后，黑客在背后做了哪些事情？ 可能会做三件事情：</li></ul> <ol><li>自动发 GET 请求 黑客网页里面可能有一段这样的代码：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">&quot;https://xxx.com/info?user=hhh&amp;count=77&quot;</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(假设你已经登录过 xxx.com 的网站) 假如服务器端没有相应的验证机制，它可能以为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作</li></ul> <ol start="2"><li>自动发 POST 请求 黑客可能自己填写了一个表单，写了一段自动提交的脚本。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>form id<span class="token operator">=</span><span class="token string">'hacker-form'</span> action<span class="token operator">=</span><span class="token string">&quot;https://xxx.com/info&quot;</span> method<span class="token operator">=</span><span class="token string">&quot;POST&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;hidden&quot;</span> name<span class="token operator">=</span><span class="token string">&quot;user&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;hhh&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;hidden&quot;</span> name<span class="token operator">=</span><span class="token string">&quot;count&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;100&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'hacker-form'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能</li></ul> <ol start="3"><li>诱导点击发送 GET 请求 在黑客的网站上，可能会放上一个链接，驱使你来点击</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">'https://xxx/info?user=hhh&amp;count=100'</span> taget<span class="token operator">=</span><span class="token string">'_blank'</span><span class="token operator">&gt;</span>
  点击进入修仙世界
<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">&gt;</span>
</code></pre></div><ul><li>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理 这就是 CSRF 攻击的原理，和 XSS 攻击做对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的 html 文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登陆状态来模拟用户进行操作</li></ul> <h3 id="防范措施-2"><a href="#防范措施-2" class="header-anchor">#</a> 防范措施:</h3> <ol><li>利用 Cookie 的 SameSite 属性 CSRF 攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此在 Cookie 上面下文章是防范的不二之选。 恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是 SameSite。</li></ol> <ul><li>SameSite 可以设置为三个值，Strict、Lax 和 None。
<ul><li><ol><li>在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求zhufeng.com网站只能在zhufeng.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</li></ol></li> <li><ol start="2"><li>在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li></ol></li> <li><ol start="3"><li>在None模式下，也就是默认模式，请求会自动携带上 Cookie。</li></ol></li></ul></li></ul> <ol start="2"><li><p>验证来源站点 这就需要要用到请求头中的两个字段: Origin和Referer。 其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。 当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p></li> <li><p>CSRF Token Django作为 Python 的一门后端框架，如果是用它开发过的同学就知道，在它的模板(template)中, 开发表单时，经常会附上这样一行代码:</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span><span class="token operator">%</span> csrf_token <span class="token operator">%</span><span class="token punctuation">}</span>
</code></pre></div><ul><li>这就是CSRF Token的典型应用。</li></ul> <div class="custom-block tip"><p class="title"></p><ul><li><strong>Token的原理：</strong> <br>
首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。 然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝</li></ul></div><h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结：</h3> <ul><li>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。 CSRF攻击一般会有三种方式:
<ul><li>自动 GET 请求</li> <li>自动 POST 请求</li> <li>诱导点击发送 GET 请求</li></ul></li> <li><strong>防范措施:</strong> 利用 Cookie 的SameSite 属性、验证来源站点和CSRF Token。</li></ul> <h2 id="_7-重绘和回流的理解"><a href="#_7-重绘和回流的理解" class="header-anchor">#</a> 7.重绘和回流的理解</h2> <ul><li>在了解重绘和回流的过程，需要先了解渲染数</li></ul> <h3 id="渲染树"><a href="#渲染树" class="header-anchor">#</a> 渲染树</h3> <h3 id="回流"><a href="#回流" class="header-anchor">#</a> 回流</h3> <ul><li>回流也叫重排</li></ul> <p><strong>触发条件：</strong></p> <ul><li>简单来说:就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生回流的过程 具体一点，有以下的操作会触发回流：</li></ul> <ol><li>一个 DOM 元素的几何属性变化，常见的几何属性有 width height padding margin left top border 等等，这个很好理解</li> <li>使 DOM 节点发生增减或者移动</li> <li>读写 offset 族、scroll 族和 client 族属性的时候，浏览器为了获取这些值，需要进行回流操作</li> <li>调用 window.getComputedStyle 方法</li></ol> <p><strong>回流过程：</strong></p> <ul><li>依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。如下图所示:</li></ul> <img src="/img/23234.png"> <ul><li>所以，回流相当于将解析和合成的过程重新又走了一遍，开销是非常大的。</li></ul> <h3 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h3> <p><strong>触发条件：</strong></p> <ul><li>当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致重绘(repaint)</li></ul> <p><strong>回流过程：</strong></p> <ul><li>由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程；流程如下图所示：</li></ul> <img src="/img/23245.png"> <ul><li>跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作；可以看到，重绘不一定导致回流，但回流一定发生了重绘</li></ul> <h3 id="合成"><a href="#合成" class="header-anchor">#</a> 合成</h3> <ul><li>还有一种情况，是直接合成。比如利用 CSS3 的 transform opacity filter 这些属性就可以实现合成的效果，也就是大家所说的 GPU 加速</li></ul> <p><strong>GUP 加速的原因：</strong></p> <ul><li>在合成的情况下，会直接跳到布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理，交给它处理有两大好处：</li></ul> <ol><li>能够充分发挥 GPU 的优势。合成线程生成位图的过程中会调用线程池，并在其中使用 GPU 进程加速生成，而 GPU 是擅长处理位图数据的</li> <li>没有占用主线程的资源，即使主线程卡住啦，效果依然能够流畅地展示</li></ol> <h2 id="_8-加快页面渲染速度-在js中的优化方式"><a href="#_8-加快页面渲染速度-在js中的优化方式" class="header-anchor">#</a> 8. 加快页面渲染速度，在JS中的优化方式</h2> <h3 id="_1-静态资源的优化"><a href="#_1-静态资源的优化" class="header-anchor">#</a> 1. 静态资源的优化</h3> <ul><li><p>主要是减少静态资源的加载时间，只要包括html、js、css和图片</p></li> <li><p>减少http请求数：合并js、css、制作雪碧图以及使用http缓存</p></li> <li><p>减少资源的大小：压缩图片、压缩文件、小兔使用base64编码</p></li> <li><p>异步组件和图片懒加载</p></li> <li><p>CDN加速和缓存(bootCND):客户端可通过最佳的网络链路加载静态资源，提高访问的速度和成功率。(CDN:通过在网络各处放置节点服务器构成的一层智能虚拟网络，可将用户的请求重新导向离用户最近的服务节点上)</p></li></ul> <h3 id="_2-接口访问的优化"><a href="#_2-接口访问的优化" class="header-anchor">#</a> 2. 接口访问的优化</h3> <ul><li><p>http持久连接(Conention:keep-alive)</p></li> <li><p>后端优化和并请求(比如在进入一个商品详情页的时候后端会提供一个接口获取商品的基本信息，然后当用户点击加入购物车时)</p></li> <li><p>数据接口缓存到localStorage，减少请求</p></li></ul> <h3 id="_3-页面渲染速度的优化"><a href="#_3-页面渲染速度的优化" class="header-anchor">#</a> 3. 页面渲染速度的优化</h3> <ul><li><p>由于浏览器的js引擎线程和GUI渲染线程是互斥的，所以在执行js的时候会阻塞它的渲染，所以一般会将css放到顶部，优先渲染，js在底部</p></li> <li><p>减少dom操作</p></li> <li><p>使用虚拟dom渲染方案，做到最小化操纵真实的dom</p></li> <li><p>事件代理：利用事件冒泡原理，把函数注册到父级元素上</p></li> <li><p>减少页面的重绘和回流</p></li></ul> <h2 id="_9-js实现事件代理"><a href="#_9-js实现事件代理" class="header-anchor">#</a> 9. JS实现事件代理</h2> <h3 id="_9-1-什么是事件代理"><a href="#_9-1-什么是事件代理" class="header-anchor">#</a> 9.1 什么是事件代理</h3> <ul><li>事件委托或事件代理：根据红宝书来说：就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举例：dom需要事件处理程序，我们都会直接给它设置事件处理程序。但是在ul中1000个li全部需要添加事件处理程序，其具有相同的点击事件，那么可以根据for来进行遍历，也可以在ul上来进行添加。在性能的角度上来看，在ul建立事件会减少dom的交互次数，提高性能。</li></ul> <h3 id="_9-2-事件代理原理"><a href="#_9-2-事件代理原理" class="header-anchor">#</a> 9.2 事件代理原理</h3> <ul><li><p>事件委托就是利用事件的冒泡原理来实现的，就是事件从最深的节点开始，然后逐步向上传播事件。</p></li> <li><p>举例：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div,有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul、li、a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件</p></li></ul> <h3 id="_9-3-实现"><a href="#_9-3-实现" class="header-anchor">#</a> 9.3 实现</h3> <h4 id="_9-2-1-实现ul中li的事件代理"><a href="#_9-2-1-实现ul中li的事件代理" class="header-anchor">#</a> 9.2.1 实现ul中li的事件代理</h4> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ul<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> oBtn<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> oUl<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> aLi<span class="token operator">=</span>oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> num<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">//事件委托，添加的子元素也有事件</span>
    oUl<span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> e<span class="token operator">=</span>e<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
        <span class="token keyword">var</span> target<span class="token operator">=</span>e<span class="token punctuation">.</span>target<span class="token operator">||</span>e<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background<span class="token operator">=</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    oUl<span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> e<span class="token operator">=</span>e<span class="token operator">||</span>window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
        <span class="token keyword">var</span> target<span class="token operator">=</span>e<span class="token punctuation">.</span>target<span class="token operator">||</span>e<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">===</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background<span class="token operator">=</span><span class="token string">&quot;blue&quot;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//添加新节点</span>
    oBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        num<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> oLi<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        oLi<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>
        oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_9-2-2-简单封装一个事件代理通用代码"><a href="#_9-2-2-简单封装一个事件代理通用代码" class="header-anchor">#</a> 9.2.2 简单封装一个事件代理通用代码</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> doc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Delegator</span> <span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//父级dom</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//代理元素及事件</span>
            <span class="token comment">//代理逻辑</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">delegator</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> currentNode <span class="token operator">=</span> e<span class="token punctuation">.</span>target <span class="token comment">//目标节点</span>
                <span class="token keyword">const</span> targetEventList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents<span class="token punctuation">[</span>e<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment">//如果当前目标节点等于事件目前所在的节点，不再往上冒泡</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode <span class="token operator">!==</span> e<span class="token punctuation">.</span>currentTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    targetEventList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">target</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>currentNode<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>matcher<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token comment">//开始委托并把当前目标节点的event对象传过去</span>
                            target<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">,</span> e<span class="token punctuation">)</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">)</span>
                    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>parentNode<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//绑定事件  event---绑定事件类型  selector---需要被代理的选择器  fn---触发函数</span>
        <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> selector<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//相同事件只能添加一次，如果存在，则在对应的代理事件里添加</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
                    <span class="token literal-property property">matcher</span><span class="token operator">:</span> selector<span class="token punctuation">,</span>
                    <span class="token literal-property property">callback</span><span class="token operator">:</span> fn
                <span class="token punctuation">}</span><span class="token punctuation">]</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>delegator<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    <span class="token literal-property property">matcher</span><span class="token operator">:</span> selector<span class="token punctuation">,</span>
                    <span class="token literal-property property">callback</span><span class="token operator">:</span> fn
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>delegatorEvents<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">eventName</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>delegator<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    root<span class="token punctuation">.</span>Delegator <span class="token operator">=</span> Delegator<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">)</span>
</code></pre></div><h2 id="_10-添加原生事件不移除的内存泄漏-js中内存泄漏"><a href="#_10-添加原生事件不移除的内存泄漏-js中内存泄漏" class="header-anchor">#</a> 10. 添加原生事件不移除的内存泄漏？JS中内存泄漏？</h2> <h3 id="_10-1-添加原生事件的问题"><a href="#_10-1-添加原生事件的问题" class="header-anchor">#</a> 10.1 添加原生事件的问题</h3> <ul><li>例如下面代码，在绑定原生事件后，不清除会有意外的情况出现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> button<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    button<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">&quot;text&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span>onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>给元素button添加了一个事件处理器onClick，而处理器里面使用了button的引用。而老版本的IE是无法检测DOM节点与JS代码之间的循环引用，因此会导致内存泄漏</li> <li>如今，现代的浏览器(包括IE和Microsoft Edge)使用了更先进的垃圾回收算法，已经正确检测和处理循环引用了。换言之，回收节点内存时，不必非要调用removeEventListener了。</li></ul> <h3 id="_10-2-js中其它内存泄漏"><a href="#_10-2-js中其它内存泄漏" class="header-anchor">#</a> 10.2 JS中其它内存泄漏</h3> <ul><li>意外的全局变量(如果必须使用全局变量存储大量数据时，确保用完以后把它设置为null或者重新定义。与全局变量相关的增加内存消耗的一个主因时缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用)</li> <li>被遗忘的计时器，尽管这个定时器不再需要，里面的回调也不再需要，可是计时器回调函数并没有被回收，这样someResource如果存储了大量的数据，也是无法被回收。因此需要把定时器清除。</li> <li>脱离DOM的引用，当你保存了一个dom的引用，然后将该dom从html中删除后，你应该将这个引用赋值为null，否则GC不会回收，这个dom仍然在内存中。保存DOM元素引用的时候，要小心谨慎</li> <li>闭包，闭包包含外面函数的活动对象，无法被GC回收</li></ul> <h2 id="_11-promise-构造函数是同步还是异步执行-then呢"><a href="#_11-promise-构造函数是同步还是异步执行-then呢" class="header-anchor">#</a> 11. Promise 构造函数是同步还是异步执行，then呢？</h2> <ul><li>Promise构造函数是同步执行的，then方法是异步执行的。例如下面的代码：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">//输出结果是：1，2，3</span>
</code></pre></div><h3 id="分析如下"><a href="#分析如下" class="header-anchor">#</a> 分析如下：</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//语法</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>构建Promise对象时，需要传入一个executor函数，主要业务流程都在executor函数中执行</li> <li>Promise构造函数执行时立即调用executor函数，resolve和reject两个函数作为参数传递给executor，resolve和reject函数被调用时，分别将promise的状态改为fulfilled(完成)或reject(失败)。一旦状态改变，就不会再变，任何时候都可以得到这个结果</li> <li>在executor函数中调用resolve函数后，会触发promise.then设置的回调函数，而调用reject函数后，会触发promise.catch设置的回调函数</li></ul> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意：</h3> <ul><li>Promise是用来管理异步编程的，它本身不是异步的，new Promise的时候会立即把executor函数执行，只不过我们一般会在executor函数中处理一个异步操作。比如下面代码中，一开始先打印出2</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">//输出结果是：2，3，1</span>
</code></pre></div><ul><li>Promise采用了回调函数延迟绑定技术，在执行resolve函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//then设置成功或失败后的处理的方法</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//p延迟绑定回调函数</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功---'</span><span class="token operator">+</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token parameter">reason</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'失败==='</span><span class="token operator">+</span>reason<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">//输出结果是：1 2 3 &quot;成功---success&quot;</span>

</code></pre></div><ul><li>new Promise的时候先执行executor函数，打印出1，2，Promise在执行resolve时，触发微任务，还是继续往下执行同步任务，执行p.then时，存储起来两个函数(此时两个函数还没有执行)，然后打印出3，此时同步任务执行完毕，最后执行刚刚的微任务，从而执行.then中成功的方法</li></ul> <h2 id="_12-项目中的异常捕获行为"><a href="#_12-项目中的异常捕获行为" class="header-anchor">#</a> 12. 项目中的异常捕获行为</h2> <h3 id="_12-1-代码执行的错误捕获"><a href="#_12-1-代码执行的错误捕获" class="header-anchor">#</a> 12.1 代码执行的错误捕获</h3> <h4 id="_12-1-1-try-catch"><a href="#_12-1-1-try-catch" class="header-anchor">#</a> 12.1.1 try...catch...</h4> <ul><li>能捕获到代码执行的错误</li> <li>捕获不到语法的错误</li> <li>无法处理异步中的错误</li> <li>使用try……catch包裹，影响代码可读性</li></ul> <h4 id="_12-1-2-window-onerror"><a href="#_12-1-2-window-onerror" class="header-anchor">#</a> 12.1.2 window.onerror</h4> <ul><li>无论是异步还是非异步错误，onerror都能捕获到运行时错误</li> <li>onerrer主要是来捕获预料之外的错误，而try……catch则是用来在可预见情况下监控特定的错误，两者结合使用更高效</li> <li>window.onerror函数只有在返回true的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示：Uncaught Error:xxxxx</li> <li>当我们遇到报404网络请求异常的时候，onerror是无法帮助我们捕获到异常的</li></ul> <div class="custom-block warning"><p class="title"></p><p>缺点：监听不到资源加载的报错error，事件处理函数只能声明一次，不会重复执行多个回调</p></div><h4 id="_12-1-3-window-addeventlistener-error-function-boolean"><a href="#_12-1-3-window-addeventlistener-error-function-boolean" class="header-anchor">#</a> 12.1.3 window.addEventListener('error',function,boolean)</h4> <ul><li>可以监听到资源加载报错，也可以注册多个事件处理函数
window.addEventListener(&quot;error&quot;,(msg,url,row,col,error)=&gt;{},true)
但是这种方式虽然可以捕捉到网络请求的异常，却无法判断HTTP的状态是<code>404</code>还是其他比如<code>500</code>等等，所以还需要配合服务端日志才进行排查分析才可以</li></ul> <h4 id="_12-1-4-window-addeventlistener-unhandledrejection"><a href="#_12-1-4-window-addeventlistener-unhandledrejection" class="header-anchor">#</a> 12.1.4 window.addEventListener('unhandledrejection')</h4> <ul><li>捕获Promise错误，当Promise被reject处理器的时候，会触发<code>unhandledrejection</code>事件；这可能发生在window下，但也可能发生在Worker中。这对于调试回退错误处理非常有用</li></ul> <h3 id="_12-2-资源加载的错误捕获"><a href="#_12-2-资源加载的错误捕获" class="header-anchor">#</a> 12.2 资源加载的错误捕获</h3> <ul><li><ol><li>imgObj.onerror()，图片不存在的时候就会触发onerror事件</li></ol></li> <li><ol start="2"><li>performance.getEntries()，获取到成功加载的资源，对比可以间接的捕获错误</li></ol></li> <li><ol start="3"><li>window.addEventListener('error',function,true)，会捕获但是不冒泡，所以window.onerror不会触发，捕获阶段可以触发</li></ol></li></ul> <h2 id="_13-promise有没有解决异步的问题"><a href="#_13-promise有没有解决异步的问题" class="header-anchor">#</a> 13. Promise有没有解决异步的问题?</h2> <p>Promise对象是JS的异步操作解决方案，为异步操作提供统一接口。它起到代理作用(proxy)，充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p> <div class="custom-block tip"><p class="title"></p><p>Promise解决了callback回调地狱的问题，async、await是异步的终级解决方案。</p></div><h3 id="_13-1-回调函数-callback"><a href="#_13-1-回调函数-callback" class="header-anchor">#</a> 13.1 回调函数 <code>callback</code></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//callback函数体</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p><strong>缺点：</strong> 回调地狱，不用try catch捕获错误，不能return</p></li> <li><p><strong>回调地狱的根本问题在于：</strong></p> <ul><li>缺乏顺序性：回调地狱导致的调试困难，和大脑的思维方式不符合</li> <li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li> <li>嵌套函数过多的话，很难处理错误</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;xxx1&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token comment">//callback函数体</span>
    <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;xxx2&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//callback函数体</span>
        <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">&quot;xxx3&quot;</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token comment">//call函数体</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><strong>优点：</strong> 解决了同步的问题---只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行</li></ul> <h3 id="_13-2-promise"><a href="#_13-2-promise" class="header-anchor">#</a> 13.2 Promise</h3> <p>Promise就是为了解决callback的问题而产生的。Promise实现了链式调用，也就是说每次then后返回的都是一个全新的Promise，如果我们在then的return，return的结果会被Promise.resolve()包装</p> <ul><li><p><strong>优点：</strong> 解决了回调地狱的问题</p></li> <li><p><strong>缺点：</strong> 无法取消Promise，错误需要通过回调函数来捕获</p></li></ul> <h3 id="_13-3-generator"><a href="#_13-3-generator" class="header-anchor">#</a> 13.3 Generator</h3> <p><strong>特点：</strong> 可以控制函数的执行，可以配合co函数库使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'xxx1'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'xxx2'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'xxx3'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> it<span class="token operator">=</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> result1<span class="token operator">=</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> result2<span class="token operator">=</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> result3<span class="token operator">=</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_13-4-async-await"><a href="#_13-4-async-await" class="header-anchor">#</a> 13.4 Async/await</h3> <p><strong>优点：</strong> 代码清晰，不用像Promise写一堆then链，处理了回调地狱的问题</p> <p><strong>缺点：</strong> await将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用await会导致性能上的降低。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//以下代码没有依赖性的话，完全可以使用Promise.all的方式</span>
    <span class="token comment">//如果有依赖性的话，其实就是解决回调地狱的例子了</span>
    <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'xxx1'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'xxx2'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'xxx3'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_14-常用的页面优化方案"><a href="#_14-常用的页面优化方案" class="header-anchor">#</a> 14. 常用的页面优化方案</h2> <h3 id="_14-1-为什么需要做优化"><a href="#_14-1-为什么需要做优化" class="header-anchor">#</a> 14.1 为什么需要做优化？</h3> <ul><li>页面性能的问题对于用户体验的影响非常大，加载时间每多1秒，你就会流失7%的用户，在正常页面的情况下，若页面加载时间超过8秒时间，那么你可能会失去85%以上的用户</li> <li>为了更好的用户体验更好的业务支持更好的代码质量，我们需要对页面进行优化</li></ul> <h3 id="_14-2-实现方案"><a href="#_14-2-实现方案" class="header-anchor">#</a> 14.2 实现方案</h3> <p>页面进行优化，有两种方案可以进行优化</p> <h4 id="_14-2-1-软件优化"><a href="#_14-2-1-软件优化" class="header-anchor">#</a> 14.2.1 软件优化</h4> <ul><li>html优化 布局优化，减少空格，不用table布局，尽量不用iframe标签</li> <li>css优化 可以用css实现的尽量不用js实现；css代码压缩；css合并；用字体图标代替图片；开启css硬件加速：transform动画由GPU控制，支持硬件加速，并不需要软件方面的渲染，使用top和left实现动画时浏览器发生的重绘和重排</li> <li>js优化 图片优化(预加载，懒加载，延时加载)；视频或音频不加载，当点击之后开始单独加载视频或音频；在js中尽量减少闭包的使用(闭包产生不释放的栈内存) DOM的操作：通过压缩css和js代码带来的减少流量</li> <li>http优化 尽量减少需要发送的http请求</li> <li>缓存方面 使用浏览器的缓存机制，不需要每次登录或者怎么样都需要再去访问服务器；利用浏览器和服务器的缓存技术(304缓存)，把一些不经常更新的静态资源文件做缓存处理</li></ul> <h4 id="_14-2-2-硬件优化"><a href="#_14-2-2-硬件优化" class="header-anchor">#</a> 14.2.2 硬件优化</h4> <ul><li>设置负载均衡服务器 --- 通过负载均衡服务器使得后台数据压力平衡</li> <li>增加宽带 --- 但是硬件的成本远远高于软件优化</li></ul> <h2 id="_15-回调函数和任务队列的区别"><a href="#_15-回调函数和任务队列的区别" class="header-anchor">#</a> 15. 回调函数和任务队列的区别</h2> <ol><li><strong>回调函数:</strong> 回调函数是作为参数传给另一个函数的函数，这个函数会在另一个函数执行完成后执行。</li> <li><strong>任务队列:</strong> 任务队列是一个事件的队列，IO设备完成一项任务后，就在队列中添加一个事件，表示相关的异步任务可以进入执行栈中了。</li></ol> <ul><li><code>同步任务：</code> 主线程上排队执行的任务，前一个任务执行完成后才能执行下一个任务</li> <li><code>异步任务：</code> 不进入主线程，进入任务队列的任务。只有当主线程上的同步任务执行完成后，主线程会读取任务队列中的任务，开始异步执行。任务队列中的事件包括IO设备的事件、用户产生的事件。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取异步任务必须指定回调函数，当主线程开始执行异步任务时，就是执行对应的回调函数。</li></ul> <h2 id="_16-jsonp工作原理"><a href="#_16-jsonp工作原理" class="header-anchor">#</a> 16. jsonp工作原理</h2> <h3 id="简介-3"><a href="#简介-3" class="header-anchor">#</a> 简介：</h3> <p>由于浏览器同源策略(同一协议，同一域名，同一端口号，当其中一个不满足的时候，请求就会发生跨域)的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案，几个简单的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">-</span> 正常的网址：http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span>
<span class="token operator">-</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span>  协议不同导致的跨域
<span class="token operator">-</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span><span class="token number">360</span><span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">8080</span>     域名不同导致的跨域
<span class="token operator">-</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">3000</span>    端口不同导致的跨域
</code></pre></div><h3 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略:</h3> <ul><li>浏览器的同源策略把跨域请求都禁止了，但是页面中link script img iframe a 标签是个例外，这些标签的外链是不受同源策略限制的。</li> <li>jsonp 就是利用上面的script 标签特性来进行跨域数据访问。</li></ul> <h3 id="jsonp-的实现机制"><a href="#jsonp-的实现机制" class="header-anchor">#</a> jsonp 的实现机制</h3> <ul><li><ol><li>与服务端约定好一个回调函数名称，在客户端定义好这个函数，在请求url中添加callback=函数名的查询字符</li></ol></li> <li><ol start="2"><li>服务端接收到请求之后，将函数名和需要返回的数据，拼接成函数名(data)函数执行的形式返回</li></ol></li> <li><ol start="3"><li>页面接收到数据后，解析完成直接执行这个回调函数，这个时候数据就成功传输了客户端</li></ol></li></ul> <h3 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结:</h3> <ul><li>利用<code>&lt;script&gt;</code>标签没有跨域限制的&quot;漏洞&quot;来达到与第三方通讯的目的</li> <li>当需要通讯的时候，网站脚本创建一个<code>&lt;script&gt;</code>元素，地址指向第三方的api网址，比如：<code>&lt;script src=&quot;http://wangyiyun.net/api?param=1&quot;&gt;&lt;/script&gt;</code>并提供一个回调函数来接收数据(函数名称自行约定或者通过地址参数传递)</li> <li>第三方产生的响应为json数据的包装(jsonp)，比如：callback({&quot;name&quot;:&quot;sunny&quot;})这样浏览器会调用callback函数，并传递解析后json对象作为参数，完成一次数据交互。</li></ul> <h3 id="注意-jsonp-不支持-post-方法"><a href="#注意-jsonp-不支持-post-方法" class="header-anchor">#</a> 注意： jsonp 不支持 post 方法</h3> <ul><li>script的src不能发送POST请求</li> <li>POST请求会引发跨域检查</li></ul> <p><strong>规范要求:</strong> 对于会给服务器产生副作用的请求，服务器都会使用OPTIONS发送一个预检请求，来获得服务器是都允许该跨域请求。</p> <h2 id="_17-object-is-与原来的比较操作符-、-的区别"><a href="#_17-object-is-与原来的比较操作符-、-的区别" class="header-anchor">#</a> 17. Object.is()与原来的比较操作符 &quot;===&quot; 、&quot;==&quot; 的区别?</h2> <ul><li>使用<code>==</code>进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较</li> <li>使用<code>===</code>进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 <code>false</code></li> <li>使用<code>Object.is</code>来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 <code>-0</code> 和 <code>+0</code> 不再相等，两个 <code>NaN</code> 认定为是相等的。</li></ul> <h2 id="_18-三种事件模型"><a href="#_18-三种事件模型" class="header-anchor">#</a> 18. 三种事件模型</h2> <p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p> <ul><li><strong>DOM0 级事件模型</strong> 第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</li> <li><strong>IE事件模型</strong> 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li> <li><strong>DOM2 级事件模型</strong> 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li></ul> <h2 id="_19-检测浏览器版本版本有哪些方式"><a href="#_19-检测浏览器版本版本有哪些方式" class="header-anchor">#</a> 19. 检测浏览器版本版本有哪些方式?</h2> <ul><li><strong>第一种是检测</strong> window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</li> <li><strong>第二种方式是功能检测</strong>，根据每个浏览器独有的特性来进行判断，如 <code>ie</code> 下独有的ActiveXObject。</li></ul> <h2 id="_20-对象的内部属性-class-是什么"><a href="#_20-对象的内部属性-class-是什么" class="header-anchor">#</a> 20. 对象的内部属性[[Class]]是什么?</h2> <ul><li>所有typeof返回值为&quot;object&quot;的对象(比如数组)都包含一个内部属性[[Class]],我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类。这个属性无法直接访问，一般通过Object.prototype.toString()来查看。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Array]&quot;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//&quot;[object Function]&quot;</span>
</code></pre></div><h2 id="_21-什么是-polyfill"><a href="#_21-什么是-polyfill" class="header-anchor">#</a> 21. 什么是 Polyfill ?</h2> <ul><li><code>Polyfill</code> 指的是用于实现浏览器并不支持的原生 API 的代码。</li> <li>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</li> <li>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。</li></ul> <h2 id="_22-javascript-代码中的-use-strict-是什么意思-为什么使用它"><a href="#_22-javascript-代码中的-use-strict-是什么意思-为什么使用它" class="header-anchor">#</a> 22. JavaScript 代码中的&quot;use strict&quot;是什么意思?为什么使用它?</h2> <ul><li><p><strong>use strict</strong> 是一种 ECMAScript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立&quot;严格模式&quot;的目的，主要有以下几个:</p> <ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为</li> <li>消除代码运行的一些不安全之处，保证代码运行的安全</li> <li>提高编译器效率，增加运行速度</li> <li>为未来新版本的 Javascript 做好铺垫</li></ul></li> <li><p><strong>use strict</strong> 指的是严格运行模式，在这种模式对 js 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有禁止使用 with 语句等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 js 语法本身的一些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。我认为严格模式代表了 js 一种更合理、更安全、更严谨的发展方向。</p></li></ul> <h2 id="_23-什么是浏览器的同源策略"><a href="#_23-什么是浏览器的同源策略" class="header-anchor">#</a> 23. 什么是浏览器的同源策略?</h2> <ul><li><p>一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的协议、域名、端口号必须相同，否则则不属于同一个域。同源政策主要限制了三个方面:</p> <ul><li><strong>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</strong></li> <li><strong>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM 。</strong></li> <li><strong>第三个是当前域下 ajax 无法发送跨域请求。</strong></li></ul></li> <li><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p></li></ul> <h2 id="_24-for-in和object-keys的区别"><a href="#_24-for-in和object-keys的区别" class="header-anchor">#</a> 24. for..in和Object.keys的区别</h2> <h3 id="_24-1-区别"><a href="#_24-1-区别" class="header-anchor">#</a> 24.1 区别：</h3> <ul><li>for..in是javascript中最常见的迭代语句，常常用来枚举对象的属性。某些情况下，可能按照随机顺序遍历数组元素</li> <li>而Object构造器有一个实例属性keys，则可以返回以对象的属性为元素的数组。数组中属性名的顺序跟使用for..in遍历返回的顺序是一样的</li> <li>for..in循环会枚举对象原型链上的可枚举属性，而object.keys不会</li></ul> <h3 id="_24-2-for-in"><a href="#_24-2-for-in" class="header-anchor">#</a> 24.2 for..in</h3> <ul><li>遍历对象上及其原型链上可枚举的属性</li> <li>如果用于遍历数组，除了遍历其元素外，还会遍历开发者对数组对象自定义的可枚举属性及其原型链上的可枚举属性；</li> <li>遍历对象返回的属性名和遍历数组返回的索引都是字符串类型</li> <li>某些情况下，可能按随机顺序遍历数组元素</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getLength</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token string">'哈哈'</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span><span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//0,1,2,val,age,getLength  所获取的是key值</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>注意：</code> 不推荐在数组中使用for in遍历</li></ul> <h3 id="_24-3-object-keys"><a href="#_24-3-object-keys" class="header-anchor">#</a> 24.3 Object.keys</h3> <ul><li>返回对象自身可枚举属性组成的数组</li> <li>不会遍历对象原型链上的属性以及Symbol属性</li> <li>对数组的遍历循序和for..in一致</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">'sunny'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
<span class="token punctuation">}</span>
<span class="token keyword">var</span> per<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>per<span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>per<span class="token punctuation">,</span><span class="token string">'like'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token comment">//不能被枚举(循环)</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token string">'singing'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//[&quot;name&quot;,&quot;age&quot;]</span>
</code></pre></div><h3 id="_24-4-for-of"><a href="#_24-4-for-of" class="header-anchor">#</a> 24.4 for of</h3> <ul><li>es6中添加的循环遍历语法</li> <li>支持遍历数组，类数组对象(DOM NodeList)，字符串，Map对象，Set对象</li> <li>不支持遍历普通对象</li> <li>遍历后输出的结果为数组元素的值</li> <li>可搭配实例方法entries(),同时输出数组的内容和索引</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//不会遍历到对象属性及其原型属性</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getLength</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length
<span class="token punctuation">}</span>
<span class="token keyword">const</span> arr<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span>
arr<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token string">'unmber'</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token string">'num'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">of</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token comment">//1,2,3</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//如果要遍历对象，可与Object.keys配合使用</span>
<span class="token keyword">const</span> person<span class="token operator">=</span><span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'sunny'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">8</span><span class="token punctuation">,</span>
    <span class="token literal-property property">like</span><span class="token operator">:</span><span class="token string">'singing'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//sunny 8 singing </span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//配合entries输出数组索引和值/对象的键值</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'deivo'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">like</span><span class="token operator">:</span><span class="token string">'football'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> <span class="token punctuation">[</span>index<span class="token punctuation">,</span>val<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token comment">//name:deivo  age:18  like:football</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_24-5-object-entries"><a href="#_24-5-object-entries" class="header-anchor">#</a> 24.5 Object.entries</h3> <ul><li><strong>Object.entries(obj)</strong> 如果参数的数据结构具有key和value，则返回一个而原数组，数组的每个元素为参数的[key,value]数组</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj<span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'sunny'</span><span class="token punctuation">,</span><span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token comment">//[&quot;name&quot;, &quot;sunny&quot;]  [&quot;age&quot;, 18]</span>
</code></pre></div><h2 id="_25-目前主流的js模块化实现的技术有哪些-他们的区别在哪儿"><a href="#_25-目前主流的js模块化实现的技术有哪些-他们的区别在哪儿" class="header-anchor">#</a> 25. 目前主流的js模块化实现的技术有哪些?他们的区别在哪儿?</h2> <h3 id="简介-4"><a href="#简介-4" class="header-anchor">#</a> 简介</h3> <p>目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统</p> <h3 id="_25-1-commonjs"><a href="#_25-1-commonjs" class="header-anchor">#</a> 25.1 CommonJS</h3> <ul><li><p><strong>CommonJS的出发点:</strong> js没有完善的模块系统，标准库较少，缺少包管理工具。伴随着NodeJS的兴起，能让JS在任何地方运行，特别是服务端，也达到了具备开发大型项目的能力，所以CommonJS营运而生。</p></li> <li><p>NodeJS是CommonJS规范的主要实践者，有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际上使用时，用module.exports定义当前模块对外输出的接口，用require加载模块。</p></li> <li><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，由于网络原因限制，更合理的方法是使用异步加载。</p> <ul><li>暴露模块：module.exports=value或exports.xxx=value</li> <li>引入模块：require(xxx)</li></ul></li></ul> <p><strong>1. CommonJS规范</strong></p> <div class="custom-block tip"><p class="title"></p><ul><li>一个文件就是一个模块，拥有单独的作用域</li> <li>普通方式定义的变量、函数、对象都属于该模块内容</li> <li>通过require来加载模块</li> <li>通过exports和module.exports来暴露块中的内容</li></ul></div><p><strong>2. 注意事项</strong></p> <div class="custom-block tip"><p class="title"></p><ul><li>当exports和module.exports同时存在，module.exports会覆盖exports</li> <li>当模块内全是exports时，就等同于module.exports</li> <li>exports就是module.exports的子集</li> <li>所有代码都运行在模块作用域，不会污染全局作用域</li> <li>模块可以多次加载，但只会在第一次加载时运行时结果就会被缓存，以后再加载的时候就直接读取缓存结果</li> <li>模块加载顺序，按照代码出现的顺序同步加载</li> <li>__dirname代表当前文件所在的文件夹路径</li> <li>__filename代表当前模块文件所在的文件夹路径+文件名</li></ul></div><h3 id="_25-2-es6模块化"><a href="#_25-2-es6模块化" class="header-anchor">#</a> 25.2 ES6模块化</h3> <ul><li><p>ES6在语言标准的层面上，实现了模块功能，而且实现的相当简单，主要为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p></li> <li><p>其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号，这类似AMD的引用写法。</p></li> <li><p>ES6的模块不是对象，import命令会被JS引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因此，是的静态分析成为可能。</p> <ul><li><ol><li>export export可以导出的是一个对象中包含的多个属性、方法。export default只能导出一个可以不具名的函数，我们可以通过import进行引用</li></ol></li> <li><ol start="2"><li>import</li></ol></li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>fn<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./xxx'</span>  <span class="token keyword">export</span>导出的方式
<span class="token keyword">import</span> fn <span class="token keyword">from</span> <span class="token string">'./xxx'</span> <span class="token keyword">export</span> <span class="token keyword">default</span>导出的方式
</code></pre></div><h3 id="_25-3-amd"><a href="#_25-3-amd" class="header-anchor">#</a> 25.3 AMD</h3> <ul><li>Asynchronous Module Definition，异步加载模块。它是一个在浏览器端模块化开发的规范，不是原生js的规范，使用AMD规范进行页面开发需要用到对应的函数库，RequireJS。</li> <li>AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</li> <li>使用require.js实现AMD规范的模块化:用require.config()指定引用路径等，用define()定义模块，用require()加载模块。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//定义模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token string">'moduleName'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> someExportValue
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//引入模块</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//执行代码逻辑</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>1. Require JS主要解决的问题</strong></p> <div class="custom-block tip"><p class="title"></p><ul><li>文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li> <li>js加载的时候浏览器会停止页面渲染，加载文件愈多，页面相应事件就越长</li> <li>异步前置加载</li></ul></div><p><strong>2. 语法 define(id,dependencies,factory)</strong></p> <div class="custom-block tip"><p class="title"></p><ul><li>id:可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名(去掉扩展名)</li> <li>dependencies是一个当前模块用来的模块名称数组</li> <li>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，应该只被执行一次，如果是对象，此对象应该为模块的输出值</li></ul></div><h3 id="_25-4-cmd"><a href="#_25-4-cmd" class="header-anchor">#</a> 25.4 CMD</h3> <p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD推崇依赖前置，提前执行，CMD推崇依赖就近，延迟执行。此规范其实是在sea.js推广过程中产生的。</p> <p>因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id；CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写<code>define(id,deps,factory)</code></p> <ul><li><p>factory有三个参数:function(require,exports,module){}</p> <ul><li>require是factory函数的第一个参数，require是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口</li> <li>exports是一个对象，用来向外提供模块接口</li> <li>module是一个对象，上面存储了与当前模块相关联的一些属性和方法</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//定义没有依赖的模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span>exports<span class="token punctuation">,</span>module</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">export</span><span class="token punctuation">.</span>xxx<span class="token operator">=</span>val
    module<span class="token punctuation">.</span>exports<span class="token operator">=</span>val
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//定义有依赖的模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span>exports<span class="token punctuation">,</span>module</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//同步引入模块</span>
    <span class="token keyword">var</span> module1<span class="token operator">=</span><span class="token function">reuqire</span><span class="token punctuation">(</span><span class="token string">'./module1.js'</span><span class="token punctuation">)</span>
    <span class="token comment">//异步引入模块</span>
    require<span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token string">'./module2.js'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//代码逻辑</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    exports<span class="token punctuation">.</span>xxx<span class="token operator">=</span>value 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//引入模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> val1<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./module1.js'</span><span class="token punctuation">)</span>
    val1<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_25-5-umd通用模块规范"><a href="#_25-5-umd通用模块规范" class="header-anchor">#</a> 25.5 UMD通用模块规范</h3> <p>一种整合CommonJS和AMD规范的方法，希望能解决跨平台模块方案</p> <p><strong>运行原理</strong></p> <ul><li>UMD先判断是否支持NodeJS的模块(exports)是否存在，存在就是用nodejs模块模式，</li> <li>在判断是否支持AMD(define是否存在)，存在则使用AMD方式加载</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">window<span class="token punctuation">,</span>factory</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'Object'</span><span class="token punctuation">{</span>
        module<span class="token punctuation">.</span>exports<span class="token operator">=</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">define</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        window<span class="token punctuation">.</span>eventUtil<span class="token operator">=</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//执行代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="总结-4"><a href="#总结-4" class="header-anchor">#</a> 总结：</h3> <ul><li>CommonJS是同步加载的。主要是在nodejs也就是服务端应用的模块化机制，通过module.export导出声明，通过require()加载。每一个文件都是一个模块。它有自己的作用域，文件内的变量，属性函数等不能被外界访问。node会将模块缓存，第二次加载会直接在缓存中获取。</li> <li>AMD是异步加载的。主要应用在浏览器环境下。requireJS是遵循AMD规范化的模块化工具。它是通过define()定义声明，通过require(['a','b'],function(a,b){})加载。</li> <li>ES6的模块的运行机制与Common不一样，js引擎对脚本静态分析的时候，遇到模块加载指令后会生成一个只读引用，等到脚本真正执行的时候才会通过去模块中获取值，在引用到执行的过程中模块中的值发生了变化，导入的这里也会跟着变化，ES6模块是动态引用，并不会缓存值，模块里总是绑定其所在的模块。</li></ul> <h2 id="_26-如何解决跨域问题"><a href="#_26-如何解决跨域问题" class="header-anchor">#</a> 26. 如何解决跨域问题?</h2> <ul><li><p>将 document.domain 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 cookie 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 iframe的话，我们也可以对这个 iframe 进行操作。如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的iframe 进行通信的问题，我们可以使用 location.hash 或者 window.name 或者postMessage 来解决问题</p></li> <li><p>使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p></li> <li><p>使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p></li> <li><p>使用 postMessage 来解决的方法，这是一个 h5 中新增的一个 api。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 postMessage 来发送信息，在窗口中我们通过对 message 信息的监听来接收信息，以此来实现不同源间的信息交换。如果是像解决 ajax 无法提交跨域请求的问题，我们可以使用 jsonp、cors、websocket 协议、服务器代理来解决问题。</p></li> <li><p>使用 jsonp 来实现跨域请求，它的主要原理是通过动态构建 script 标签来实现跨域请求，因为浏览器对 script 标签的引入没有跨域的访问限制 。通过在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 get请求。</p></li> <li><p>使用 CORS 的方式，CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;。CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 CORS 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p></li> <li><p>使用 websocket 协议，这个协议没有同源限制。</p></li> <li><p>使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p></li></ul> <h2 id="_27-什么是函数柯里化"><a href="#_27-什么是函数柯里化" class="header-anchor">#</a> 27. 什么是函数柯里化?</h2> <p>把接收多个参数的函数变换为接收一个单一参数（最初函数的第一个参数）的函数，并返回接收剩余参数而且返回结果的新函数的技术。</p> <h3 id="函数柯里化特点"><a href="#函数柯里化特点" class="header-anchor">#</a> 函数柯里化特点：</h3> <ul><li>可以延迟计算，即如果调用柯里化函数传入参数是不调用的，会将参数添加到数组中存储，等到没有参数传入的时候进行调用；</li> <li>参数复用，当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化函数</li></ul> <h2 id="_28-异步编程的实现方式是什么"><a href="#_28-异步编程的实现方式是什么" class="header-anchor">#</a> 28. 异步编程的实现方式是什么?</h2> <ul><li><p>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是：多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护.</p></li> <li><p>第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p></li> <li><p>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p></li> <li><p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p></li></ul> <h2 id="_29-说一下import的原理-和require的不同之处在哪儿"><a href="#_29-说一下import的原理-和require的不同之处在哪儿" class="header-anchor">#</a> 29. 说一下import的原理，和require的不同之处在哪儿?</h2> <h3 id="import原理-实际上就是es6-module的原理"><a href="#import原理-实际上就是es6-module的原理" class="header-anchor">#</a> import原理(实际上就是ES6 module的原理)</h3> <ol><li>简单来说就是闭包作用</li> <li>为了创建Module的内部作用域，会调用一个包装函数</li> <li>包装函数的返回值也就是Module向外公开的API，也就是所有export出去的变量</li> <li>import是拿到module导出变量的引用</li></ol> <h3 id="import与require区别"><a href="#import与require区别" class="header-anchor">#</a> import与require区别：</h3> <ul><li>CommonJS模块输出的是一个值的拷贝，ES6模块输出的值的引用</li> <li>CommonJS模块是运行时加载，ES6模块是编译时输出接口</li> <li>CommonJS是运行时加载对应模块，一旦输出一个值，即使模块内部对其做出改变，也不影响输出值。而ES6模块不同，import导入是在JS引擎对脚步静态分析时确定，获取到的是一个只读引用。等脚本引擎运行时，会根据这个引用去对应模块中的取值，所以引用对应的值改变的时候，其导入的值也会发生改变。</li></ul> <h2 id="_30-如何理解观察者模式"><a href="#_30-如何理解观察者模式" class="header-anchor">#</a> 30. 如何理解观察者模式</h2> <h3 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h3> <p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新</p> <h3 id="主要解决的问题"><a href="#主要解决的问题" class="header-anchor">#</a> 主要解决的问题</h3> <p>一个对象状态改变给其他对象通知的问题，而且考虑到易用和低耦合，保证高度的协作</p> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li>观察者和被观察者是抽象耦合的</li> <li>建立一套触发机制</li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ul><li>如果一个被观察对象有很多的直接和间接的观察者的话，将所有的观察者都通知道会花费很多时间。</li> <li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统奔溃</li> <li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎样发生变化的，而仅仅只是知道观察目标发生了变化</li></ul> <h2 id="_31-symbol-值的强制类型转换"><a href="#_31-symbol-值的强制类型转换" class="header-anchor">#</a> 31. Symbol 值的强制类型转换?</h2> <ul><li>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</li> <li>Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换 为布尔值(显式和隐式结果都是 true)</li></ul> <h2 id="_32-说一下你理解的-https-中间人攻击"><a href="#_32-说一下你理解的-https-中间人攻击" class="header-anchor">#</a> 32. 说一下你理解的 HTTPS 中间人攻击 ?</h2> <h3 id="前言"><a href="#前言" class="header-anchor">#</a> 前言：</h3> <p><strong>https</strong> 协议由 http + ssl 协议构成。</p> <h3 id="中间人攻击过程如下"><a href="#中间人攻击过程如下" class="header-anchor">#</a> 中间人攻击过程如下：</h3> <div class="custom-block tip"><p class="title"></p><ol><li>服务器向客户端发送公钥；</li> <li>攻击者截获公钥，保留在自己手上；</li> <li>然后攻击者自己生成一个【伪造的】公钥，发给客户端；</li> <li>客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；</li> <li>攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；</li> <li>同时生成假的加密 hash 值，发给服务器；</li> <li>服务器用私钥解密获得假秘钥；</li> <li>服务器用假秘钥加密传输信息；</li></ol></div><h3 id="防范方法"><a href="#防范方法" class="header-anchor">#</a> 防范方法：</h3> <ul><li>服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。</li></ul> <h2 id="_33-判断一个对象是否属于某个类"><a href="#_33-判断一个对象是否属于某个类" class="header-anchor">#</a> 33. 判断一个对象是否属于某个类?</h2> <ul><li><p>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置</p></li> <li><p>第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写</p></li> <li><p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用Object.prototype.toString.call() 方法来打印对象的[[Class]] 属性来进行判断</p></li></ul> <h2 id="_34-什么是dom和bom"><a href="#_34-什么是dom和bom" class="header-anchor">#</a> 34. 什么是DOM和BOM?</h2> <ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</li> <li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul> <h2 id="_35-说一下base64的编码方式"><a href="#_35-说一下base64的编码方式" class="header-anchor">#</a> 35. 说一下base64的编码方式</h2> <h2 id="_36-说一下ajax-axios-fetch三者的区别"><a href="#_36-说一下ajax-axios-fetch三者的区别" class="header-anchor">#</a> 36. 说一下ajax/axios/fetch三者的区别</h2> <h3 id="_1-ajax"><a href="#_1-ajax" class="header-anchor">#</a> 1. ajax</h3> <ul><li><p>ajax是对原生xhr的封装，除此之外还增添了对jsonp的支持。JQuery ajax经过多年的更新维护十分方便了，如果说还有缺点的话，那就是:</p> <ul><li>本身是针对MVC的编程，不符合现在的前端MVVM的潮流</li> <li>基于原生的xhr的开发，xhr本身的架构不清晰，已经有fetch的替代方案</li> <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常不合理(采取个性化打包的方案又不能享受CDN服务)</li> <li>尽管JQuery对前端的开发工作有着深远的影响，但是随着vue，react新一代的崛起以及ES规范的完善，更多api的更新，JQuery这种大而全的js库，未来的道路会越来越窄</li></ul></li></ul> <h3 id="_2-axios"><a href="#_2-axios" class="header-anchor">#</a> 2. axios</h3> <ul><li><p>axios本质上也是对原生xhr的封装，只不过是promise的版本，符合最新的ES规范，从其官网上可以看到以下几条特性：</p> <ul><li>从node.js创建http请求</li> <li>支持Promise api</li> <li>客户端支持防止CSRF</li> <li>提供了一些并发请求的接口</li> <li>防止CSRF的攻击实现原理：在每个请求都带一个cookie中拿到的key，根据浏览器的同源策略，假冒的网站是拿不到cookie中的key，这样后台轻松辨别出这个请求是否是用户在假冒网站上的误导输入从而采取正确的策略</li></ul></li> <li><p>axios提供了并发的封装，体积较少，是非常使用当下潮流的方式</p></li></ul> <h3 id="_3-fetch"><a href="#_3-fetch" class="header-anchor">#</a> 3. fetch</h3> <ul><li>fetch号称是ajax的替代品。它的好处有以下几点
<ul><li>语法简洁，更加语义化</li> <li>基于promise实现，支持async/await</li> <li>更加接近底层，提供丰富的api</li> <li>脱离了xhr，是ES规范的新的实现方式</li></ul></li></ul> <h2 id="_37-reflect-对象创建目的是什么"><a href="#_37-reflect-对象创建目的是什么" class="header-anchor">#</a> 37. Reflect 对象创建目的是什么?</h2> <ul><li>将 Object 对象的一些明显属于语言内部的方法（ 如：Object.defineProperty）放到 Reflect 对象上。</li> <li>修改某些 Object 方法的返回结果，让其变得更合理。</li> <li>让 Object 操作都变成函数行为。</li></ul> <div class="custom-block tip"><p class="title"></p><p>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。</p></div><h2 id="_38-你所理解的前端路由是什么"><a href="#_38-你所理解的前端路由是什么" class="header-anchor">#</a> 38. 你所理解的前端路由是什么?</h2> <h3 id="_1-基于hash"><a href="#_1-基于hash" class="header-anchor">#</a> 1. 基于hash</h3> <ul><li><p>展示页面也就是切换#后面的内容，呈现给用户不同的页面。现在越来越多的单页面应用基本都是基于hash实现的</p></li> <li><p>特性:url中hash值的变化并不会重新加载页面，hash值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制hash的切换</p></li> <li><p>我们可以通过hashchange事件，监听到hash值的变化，从而响应不同路径的逻辑处理</p></li></ul> <h3 id="_2-基于history"><a href="#_2-基于history" class="header-anchor">#</a> 2. 基于history</h3> <ul><li><p>基于history新API(history.pushState()+popState事件) window.history.pushState(null,null,&quot;https://www.baidu.com&quot;)</p></li> <li><p>这两个API的相同之处都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于:pushState会增加一条新的历史记录，而replace则会替换当前的历史记录</p></li></ul> <h2 id="_39-介绍你所理解的中介者模式"><a href="#_39-介绍你所理解的中介者模式" class="header-anchor">#</a> 39. 介绍你所理解的中介者模式?</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <ul><li>中介者模式(Mediator Pattern)是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。使用中介者模式来集中相关对象之间复杂的沟通和控制方式。</li> <li><code>意思：</code> 用一个中介对象来封装一系列的对象交互，中介者使各个对象不需要显式的相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li></ul> <h3 id="主要解决"><a href="#主要解决" class="header-anchor">#</a> 主要解决</h3> <ul><li>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</li></ul> <h3 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h3> <ul><li>MVC框架，其中C(控制器)就是M(模型)和V(视图)的中介者。前端的MVVM框架本质是MVC框架的变形，VM(控制器)就是M(模型)和V(视图)的中介者</li></ul> <h3 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h3> <ul><li>通过将对象彼此解耦，可以增加对象的复用性</li> <li>通过将控制逻辑集中，可以简化系统维护</li> <li>可以让对象之间所传递的消息变得简单而且大幅减少</li></ul> <h3 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h3> <ul><li>中介者常常被用来协调相关的GUI组件</li> <li>如果设计不当，中介者对象本身会变得过于复杂</li></ul> <h2 id="_40-base64的编码方式"><a href="#_40-base64的编码方式" class="header-anchor">#</a> 40. base64的编码方式？</h2> <h3 id="编码原理"><a href="#编码原理" class="header-anchor">#</a> 编码原理：</h3> <p>Base64是一种编码方式。选用大小写字母、数字0-9、+和/的64个可打印字符来表示二进制数据。将二进制数据每三个字节为一组。一共是3*8=24bit(位)，划分为四组，每一组为6bit(位)。如果要编码的二进制不是3的倍数，会用00在末尾补足，然后在编码的末尾加上1-2个=号，表示补了多少字节，解码的时候会去掉。将3个字节的二进制数据编码为4字节的文本，解码的时候会去掉。将3字节的二进制数据编码为4字节的文本，是可以让数据在邮件正文、网页等直接显示的。</p> <h3 id="编码解释"><a href="#编码解释" class="header-anchor">#</a> 编码解释：</h3> <p>Base64是传输8bit字节码的编码方式，Base64可以将ASCII字符串或者二进制编码只包含A-Z、a-z、0-9、+、/这64个字符(26个大写字母，26个小写字母，10个数字，一个+，一个/ 刚好组成64个字符)；这64个字符用6个bit就可以全部表示出来，一个字节有8个bit位，那么还剩下两个bit位，那这两个bit位用来补充，转换完空的结果是用&quot;=&quot;来补位，总之要保证最后编码出来的字节数是4的倍数</p> <p><code>注意事项：</code> 因为标准的Base64会有+和/在URL中不能直接做参数，于是出现了一种&quot;url safe&quot;的Base64，将+和/转换为-和_。因为=用在URL和cookie会有歧义，所以很多Base64会把=去掉。由于Base的长度永远是4的倍数，所以只要加上=把长度变为4的倍数，就可以解码了。</p> <h2 id="_41-require模式引入的查找方式是什么"><a href="#_41-require模式引入的查找方式是什么" class="header-anchor">#</a> 41. require模式引入的查找方式是什么?</h2> <p>当node遇到require(x)时，按照下面的顺序处理</p> <ol><li>如果 X 是内置模块（比如 require('http')） a. 返回该模块。 b. 不再继续执行。</li> <li>如果 X 以 &quot;./&quot; 或者 &quot;/&quot; 或者 &quot;../&quot; 开头 a. 根据 X 所在的父模块，确定 X 的绝对路径。 b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续 执行。 X X.js X.json X.node
c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。 X/package.json（main 字段） X/index.js X/index.json X/index.node</li> <li>如果 X 不带路径 a. 根据 X 所在的父模块，确定 X 可能的安装目录。 b. 依次在每个目录中，将 X 当成文件名或目录名加载。</li> <li>抛出 &quot;not found&quot;</li></ol> <h2 id="_42-面向对象的三要素是什么-分别是什么意思"><a href="#_42-面向对象的三要素是什么-分别是什么意思" class="header-anchor">#</a> 42. 面向对象的三要素是什么，分别是什么意思?</h2> <p><strong>封装:</strong> 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏</p> <p><strong>继承:</strong> 使用现有类的所有功能并在无需重新编写原来的类的情况下对这些功能进行扩展</p> <p><strong>多态:</strong> 一个类实例的相同方法在不同情形下有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口</p> <h2 id="_43-字符串陷阱-请输出结果并进行解释"><a href="#_43-字符串陷阱-请输出结果并进行解释" class="header-anchor">#</a> 43. 字符串陷阱 请输出结果并进行解释</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//字符串陷阱   请输出结果并进行解释</span>
<span class="token keyword">function</span> <span class="token function">showCase</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">'A'</span><span class="token operator">:</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Case A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token string">'B'</span><span class="token operator">:</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Case B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token keyword">undefined</span><span class="token operator">:</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Do not know!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">showCase</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>返回结果：’Do not know!‘</li> <li>原因：在 switch 内部使用严格相等 === 进行判断，并且 new String(&quot;A&quot;) 返回的是一个对象，而 String(&quot;A&quot;) 则是直接返回字符串 &quot;A&quot;。你也可以参考MDN中对原始字符串和String对象的区分,查看相关的资料</li></ul> <h2 id="_44-提升变量-请输出结果并进行解释"><a href="#_44-提升变量-请输出结果并进行解释" class="header-anchor">#</a> 44. 提升变量 请输出结果并进行解释</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'spring'</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'summer'</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>返回结果：summer</li> <li>原因：
<ul><li>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</li> <li>这意味着你可以在声明一个函数或变量之前引用它，或者可以说：一个变量或函数可以在它被引用之后声明。</li></ul></li></ul> <h2 id="_45-添加元素-指定位置添加"><a href="#_45-添加元素-指定位置添加" class="header-anchor">#</a> 45. 添加元素(指定位置添加)</h2> <ul><li>添加元素(指定位置添加) 描述：在数组arr的index处添加元素item，不要直接修改数组arr，结果返回新的数组 [1,2,3] 2,6 结果为[1,2,6,3]</li></ul> <h3 id="_1-使用splice方法插入-效率较高"><a href="#_1-使用splice方法插入-效率较高" class="header-anchor">#</a> 1. 使用splice方法插入（效率较高）</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-push-apply-splice"><a href="#_2-push-apply-splice" class="header-anchor">#</a> 2. push.apply + splice</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    temp<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> resArr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-先复制前0-index个元素-将item元素插入之后-再拼接index之后的元素"><a href="#_3-先复制前0-index个元素-将item元素插入之后-再拼接index之后的元素" class="header-anchor">#</a> 3. 先复制前0~index个元素，将item元素插入之后，再拼接index之后的元素</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> temp <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>temp<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">]</span><span class="token punctuation">;</span>
    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_46-filter过滤器-请输出结果并进行解释"><a href="#_46-filter过滤器-请输出结果并进行解释" class="header-anchor">#</a> 46. filter过滤器 请输出结果并进行解释</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> ary <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
ary<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
ary<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>返回的结果：[]</li> <li><code>原因：</code> 看MDN官方文档的描述，filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。
MDN：Array.prototype.filter() 可以MDN文档资料查询</li></ul> <h2 id="_47-优先级顺序-请输出结果并进行解释"><a href="#_47-优先级顺序-请输出结果并进行解释" class="header-anchor">#</a> 47. 优先级顺序 请输出结果并进行解释</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> val <span class="token operator">=</span> <span class="token string">'smtg'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Value is '</span> <span class="token operator">+</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> <span class="token string">'smtg'</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">'Something'</span> <span class="token operator">:</span> <span class="token string">'Nothing'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><ul><li>返回结果：'Something'</li> <li>实际上输出 &quot;Something&quot;，因为 + 的优先级比条件运算符 condition ? val1 : val2 的优先级高。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="_48-查找数组元素位置"><a href="#_48-查找数组元素位置" class="header-anchor">#</a> 48. 查找数组元素位置</h2> <ul><li>找出元素item在给定数组arr中的位置 描述：如果数组中存在item就返回元素在数组中的位置，否则就会返回-1 [1,2,3,4,5,6] --&gt; 存在3就输出2，存在7输出-1</li></ul> <h3 id="方法1"><a href="#方法1" class="header-anchor">#</a> 方法1:</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断浏览器是否支持indexOf方法 </span>
        <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="方法2"><a href="#方法2" class="header-anchor">#</a> 方法2:</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断浏览器是否支持indexOf方法 </span>
        <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_49-函数式编程-compose-函数"><a href="#_49-函数式编程-compose-函数" class="header-anchor">#</a> 49. 函数式编程 Compose 函数</h2> <h3 id="简介-5"><a href="#简介-5" class="header-anchor">#</a> 简介</h3> <p><strong>Compose</strong> 是函数式编程中一个非常重要的函数，compose的函数作用就是组合函数的，将函数串联起来执行。将多个函数组合起来，一个函数的输出结果是另一个函数的输入函数，一旦第一个函数开始执行，就会像多米诺骨牌一样推导执行</p> <h3 id="实现方式"><a href="#实现方式" class="header-anchor">#</a> 实现方式</h3> <h4 id="_1-递归实现"><a href="#_1-递归实现" class="header-anchor">#</a> 1. 递归实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>funcs</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> len <span class="token operator">=</span> funcs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 首先compose 返回的是一个函数</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 函数体里就是不断执行args函数，将上一个函数的执行结果作为</span>
        <span class="token comment">// 下一个执行函数的输入参数，需要一个count来记录args函数列</span>
        <span class="token comment">// 表的执行情况</span>
        result <span class="token operator">=</span> funcs<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 递归退出条件</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> result<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            count<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 测试</span>
<span class="token keyword">const</span> <span class="token function-variable function">greeting</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">toUpper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">,</span> greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">&quot;sunny&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_2-迭代实现"><a href="#_2-迭代实现" class="header-anchor">#</a> 2. 迭代实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>func</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> isFirst <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span>  <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFirst<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      isFirst <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 测试</span>
<span class="token keyword">const</span> <span class="token function-variable function">greeting</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">toUpper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">,</span> greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">&quot;sunny&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="_3-lodash-js-库实现"><a href="#_3-lodash-js-库实现" class="header-anchor">#</a> 3. lodash.js 库实现</h4> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><ul><li>lodash的实现是从左到右实现的，但是也提供了从右到左的flowRight，还多了一层函数的校验，而且接收到的是数组而不是参数序列</li></ul> <h2 id="_50-发起一个请求到拿到响应-中间经过了0-3s-那么tcp三次握手经历的时间是多少"><a href="#_50-发起一个请求到拿到响应-中间经过了0-3s-那么tcp三次握手经历的时间是多少" class="header-anchor">#</a> 50. 发起一个请求到拿到响应，中间经过了0.3s，那么tcp三次握手经历的时间是多少？</h2> <h2 id="_51-js为什么要区分微任务和宏任务"><a href="#_51-js为什么要区分微任务和宏任务" class="header-anchor">#</a> 51. JS为什么要区分微任务和宏任务?</h2> <ul><li><p>区分微任务和宏任务是为了将异步队列任务划分优先级，通俗的理解可以方便插队</p></li> <li><p>一个事件循环(<code>Event Loop</code>)：微任务(<code>Micro task</code>)在宏任务(<code>Macro task</code>)之后调用，微任务(<code>Micro task</code>)会在下一个事件循环(<code>Event Loop</code>)之前执行调用完，并且其中会将微任务(<code>Micro task</code>)执行当中新注册的微任务(<code>Micro task</code>)一并调用执行完，然后才开始下一次的事件循环(<code>Event Loop</code>)，所以如果有新的宏任务(<code>Macro task</code>)就需要一直等待，等到上一个事件循环当中微任务(<code>Micro task</code>)被清空为止。由此可见。我们可以在下一次事件循环(<code>Event Loop</code>)之前进行插队。</p></li> <li><p>如果不区分微任务(<code>Micro task</code>)和宏任务(<code>Macro task</code>)的话，那就无法在下一次事件循环之前进行插队，其中新注册的任务得等到下一个宏任务(<code>Macro task</code>)完成之后才能进行，这中间需要的状态就无法在下一个宏任务(<code>Micro task</code>)中得到同步。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 队列1，2，3，4，5；5是插队的，</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5 实现了插队，先打印</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 5打印了，通知下面，让其打印</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_52-讲一下你所了解的函数式编程"><a href="#_52-讲一下你所了解的函数式编程" class="header-anchor">#</a> 52. 讲一下你所了解的函数式编程</h2> <h3 id="理解"><a href="#理解" class="header-anchor">#</a> 理解</h3> <ul><li><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程、逻辑式编程，常见的面向对象编程也是一种命令式编程。</p></li> <li><p>如果说面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系，那么函数式编程的思维方式是：把现实世界的事物和事物之间的联系抽象到程序世界(对运算过程进行抽象)。函数编程中的函数，不是指计算机中的函数，而是指数学中的函数。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。并且相同的值输入得到相同的结果，纯函数。</p></li> <li><p>在函数式语言中，函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。简单的理解就是:函数式编程用来描述数据(函数)直接的映射</p></li></ul> <h3 id="优点-3"><a href="#优点-3" class="header-anchor">#</a> 优点</h3> <ul><li><p>函数时编程的优点是由它的不可变性带来的，以下几点进行描述:</p> <ul><li>函数式编程可以抛弃this</li> <li>打包过程中可以更好的利用tree shaking过滤无用代码</li> <li>函数不依赖外部的状态，也不修改外部的状态，函数调用的结果不依赖函数调用的时间和调用的位置，这样的代码容易进行推理且不易出错，还可以把运行的结果进行缓存。同时，方便进行单元测试，方便进行处理
由于函数式语言是面向数学的抽象，更接近人的语言，而不是机器的语言，代码比较简洁，也更容易理解</li></ul></li></ul> <h3 id="风险"><a href="#风险" class="header-anchor">#</a> 风险</h3> <ul><li>函数式编程的不可变性如果掺入可变性就带来了风险。如果一个纯函数掺入可变性就不再是纯函数啦，也就是如果函数依赖外部的状态接没有办法保证输出相同，就会带来副作用。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> num<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">com</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> val<span class="token operator">===</span>num
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>这个函数依赖外部的是num，如果num变成别的数字或者内容，那么的话相同的输入就变成不同的输出啦，这个副作用是不可避免的。一般副作用的来源：配置文件、数据库、获取用户的输入…</p></li> <li><p>所有的外部交互都有可能带出副作用，副作用会给程序带来安全隐患，给程序带来不确定性，同时副作用不可能完全禁止，只能尽力控制它们在可控的范围内发生</p></li></ul> <h2 id="_53-手写实现下object-freeze"><a href="#_53-手写实现下object-freeze" class="header-anchor">#</a> 53. 手写实现下Object.freeze</h2> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <ul><li><p>内置类 <strong>Object.freeze()</strong> 方法可以冻结一个对象</p> <ul><li>不能向这个对象添加新的属性</li> <li>不能修改现有属性的值</li> <li>不能删除属性</li> <li>不能修改这个对象现有属性的可枚举性、可配置性、可写性</li></ul></li> <li><p>换句话来说，这个对象永远是不可变的</p></li></ul> <div class="custom-block warning"><p class="title"></p><p><strong>注意：</strong> Object.freeze 是 <strong><code>浅冻结</code></strong></p></div><h3 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'deivo'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  <span class="token literal-property property">likes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">ball</span><span class="token operator">:</span> <span class="token string">'football'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">sports</span><span class="token operator">:</span> <span class="token string">'吃鸡'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;rita&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'deivo' </span>
</code></pre></div><ul><li><strong>浅冻结</strong></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'deivo'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
  <span class="token literal-property property">likes</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">ball</span><span class="token operator">:</span> <span class="token string">'Football'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">sports</span><span class="token operator">:</span> <span class="token string">'吃鸡'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>likes<span class="token punctuation">.</span>ball <span class="token operator">=</span> <span class="token string">'Basketball'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>likes<span class="token punctuation">.</span>ball<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Basketball' </span>
</code></pre></div><h3 id="原理模拟实现"><a href="#原理模拟实现" class="header-anchor">#</a> 原理模拟实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">freeze</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> val <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 只读，不能写</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
                Object<span class="token punctuation">.</span><span class="token function">seal</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 封闭对象 </span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>总结：</strong> <ul><li><code>Object.defineProperty()</code> 方法定义对象属性的特性，比如是否删除，是否修改，是否可枚举等</li> <li><code>Object.seal()</code> 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置</li></ul></li></ul> <h2 id="_54"><a href="#_54" class="header-anchor">#</a> 54.</h2></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_1-两个正整数的最大回文产品" class="sidebar-link reco-side-_1-两个正整数的最大回文产品" data-v-cb1513f6>1. 两个正整数的最大回文产品</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_2-神奇的-null-请输出结果并进行解释" class="sidebar-link reco-side-_2-神奇的-null-请输出结果并进行解释" data-v-cb1513f6>2. 神奇的 null 请输出结果并进行解释</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-浏览器的本地存储" class="sidebar-link reco-side-_3-浏览器的本地存储" data-v-cb1513f6>3. 浏览器的本地存储</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-1-cookie-了解" class="sidebar-link reco-side-_3-1-cookie-了解" data-v-cb1513f6>3.1 cookie 了解</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-2-webstorage-了解" class="sidebar-link reco-side-_3-2-webstorage-了解" data-v-cb1513f6>3.2 WebStorage 了解</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_4-防抖节流原理、区别、应用以及实现" class="sidebar-link reco-side-_4-防抖节流原理、区别、应用以及实现" data-v-cb1513f6>4. 防抖节流原理、区别、应用以及实现</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#防抖" class="sidebar-link reco-side-防抖" data-v-cb1513f6>防抖</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#节流" class="sidebar-link reco-side-节流" data-v-cb1513f6>节流</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#防抖和节流区别" class="sidebar-link reco-side-防抖和节流区别" data-v-cb1513f6>防抖和节流区别：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_5-xss-攻击的理解" class="sidebar-link reco-side-_5-xss-攻击的理解" data-v-cb1513f6>5. XSS 攻击的理解</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#简介" class="sidebar-link reco-side-简介" data-v-cb1513f6>简介：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#分类" class="sidebar-link reco-side-分类" data-v-cb1513f6>分类：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#防范措施" class="sidebar-link reco-side-防范措施" data-v-cb1513f6>防范措施：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#总结" class="sidebar-link reco-side-总结" data-v-cb1513f6>总结：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_6-csrf-攻击" class="sidebar-link reco-side-_6-csrf-攻击" data-v-cb1513f6>6.CSRF 攻击？</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#简介-2" class="sidebar-link reco-side-简介-2" data-v-cb1513f6>简介：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#防范措施-2" class="sidebar-link reco-side-防范措施-2" data-v-cb1513f6>防范措施:</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#总结-2" class="sidebar-link reco-side-总结-2" data-v-cb1513f6>总结：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_7-重绘和回流的理解" class="sidebar-link reco-side-_7-重绘和回流的理解" data-v-cb1513f6>7.重绘和回流的理解</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#渲染树" class="sidebar-link reco-side-渲染树" data-v-cb1513f6>渲染树</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#回流" class="sidebar-link reco-side-回流" data-v-cb1513f6>回流</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#重绘" class="sidebar-link reco-side-重绘" data-v-cb1513f6>重绘</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#合成" class="sidebar-link reco-side-合成" data-v-cb1513f6>合成</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_8-加快页面渲染速度-在js中的优化方式" class="sidebar-link reco-side-_8-加快页面渲染速度-在js中的优化方式" data-v-cb1513f6>8. 加快页面渲染速度，在JS中的优化方式</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_1-静态资源的优化" class="sidebar-link reco-side-_1-静态资源的优化" data-v-cb1513f6>1. 静态资源的优化</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_2-接口访问的优化" class="sidebar-link reco-side-_2-接口访问的优化" data-v-cb1513f6>2. 接口访问的优化</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-页面渲染速度的优化" class="sidebar-link reco-side-_3-页面渲染速度的优化" data-v-cb1513f6>3. 页面渲染速度的优化</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_9-js实现事件代理" class="sidebar-link reco-side-_9-js实现事件代理" data-v-cb1513f6>9. JS实现事件代理</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_9-1-什么是事件代理" class="sidebar-link reco-side-_9-1-什么是事件代理" data-v-cb1513f6>9.1 什么是事件代理</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_9-2-事件代理原理" class="sidebar-link reco-side-_9-2-事件代理原理" data-v-cb1513f6>9.2 事件代理原理</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_9-3-实现" class="sidebar-link reco-side-_9-3-实现" data-v-cb1513f6>9.3 实现</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_10-添加原生事件不移除的内存泄漏-js中内存泄漏" class="sidebar-link reco-side-_10-添加原生事件不移除的内存泄漏-js中内存泄漏" data-v-cb1513f6>10. 添加原生事件不移除的内存泄漏？JS中内存泄漏？</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_10-1-添加原生事件的问题" class="sidebar-link reco-side-_10-1-添加原生事件的问题" data-v-cb1513f6>10.1 添加原生事件的问题</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_10-2-js中其它内存泄漏" class="sidebar-link reco-side-_10-2-js中其它内存泄漏" data-v-cb1513f6>10.2 JS中其它内存泄漏</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_11-promise-构造函数是同步还是异步执行-then呢" class="sidebar-link reco-side-_11-promise-构造函数是同步还是异步执行-then呢" data-v-cb1513f6>11. Promise 构造函数是同步还是异步执行，then呢？</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#分析如下" class="sidebar-link reco-side-分析如下" data-v-cb1513f6>分析如下：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#注意" class="sidebar-link reco-side-注意" data-v-cb1513f6>注意：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_12-项目中的异常捕获行为" class="sidebar-link reco-side-_12-项目中的异常捕获行为" data-v-cb1513f6>12. 项目中的异常捕获行为</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_12-1-代码执行的错误捕获" class="sidebar-link reco-side-_12-1-代码执行的错误捕获" data-v-cb1513f6>12.1 代码执行的错误捕获</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_12-2-资源加载的错误捕获" class="sidebar-link reco-side-_12-2-资源加载的错误捕获" data-v-cb1513f6>12.2 资源加载的错误捕获</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_13-promise有没有解决异步的问题" class="sidebar-link reco-side-_13-promise有没有解决异步的问题" data-v-cb1513f6>13. Promise有没有解决异步的问题?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_13-1-回调函数-callback" class="sidebar-link reco-side-_13-1-回调函数-callback" data-v-cb1513f6>13.1 回调函数 callback</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_13-2-promise" class="sidebar-link reco-side-_13-2-promise" data-v-cb1513f6>13.2 Promise</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_13-3-generator" class="sidebar-link reco-side-_13-3-generator" data-v-cb1513f6>13.3 Generator</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_13-4-async-await" class="sidebar-link reco-side-_13-4-async-await" data-v-cb1513f6>13.4 Async/await</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_14-常用的页面优化方案" class="sidebar-link reco-side-_14-常用的页面优化方案" data-v-cb1513f6>14. 常用的页面优化方案</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_14-1-为什么需要做优化" class="sidebar-link reco-side-_14-1-为什么需要做优化" data-v-cb1513f6>14.1 为什么需要做优化？</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_14-2-实现方案" class="sidebar-link reco-side-_14-2-实现方案" data-v-cb1513f6>14.2 实现方案</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_15-回调函数和任务队列的区别" class="sidebar-link reco-side-_15-回调函数和任务队列的区别" data-v-cb1513f6>15. 回调函数和任务队列的区别</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_16-jsonp工作原理" class="sidebar-link reco-side-_16-jsonp工作原理" data-v-cb1513f6>16. jsonp工作原理</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#简介-3" class="sidebar-link reco-side-简介-3" data-v-cb1513f6>简介：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#同源策略" class="sidebar-link reco-side-同源策略" data-v-cb1513f6>同源策略:</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#jsonp-的实现机制" class="sidebar-link reco-side-jsonp-的实现机制" data-v-cb1513f6>jsonp 的实现机制</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#总结-3" class="sidebar-link reco-side-总结-3" data-v-cb1513f6>总结:</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#注意-jsonp-不支持-post-方法" class="sidebar-link reco-side-注意-jsonp-不支持-post-方法" data-v-cb1513f6>注意： jsonp 不支持 post 方法</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_17-object-is-与原来的比较操作符-、-的区别" class="sidebar-link reco-side-_17-object-is-与原来的比较操作符-、-的区别" data-v-cb1513f6>17. Object.is()与原来的比较操作符 &quot;===&quot; 、&quot;==&quot; 的区别?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_18-三种事件模型" class="sidebar-link reco-side-_18-三种事件模型" data-v-cb1513f6>18. 三种事件模型</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_19-检测浏览器版本版本有哪些方式" class="sidebar-link reco-side-_19-检测浏览器版本版本有哪些方式" data-v-cb1513f6>19. 检测浏览器版本版本有哪些方式?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_20-对象的内部属性-class-是什么" class="sidebar-link reco-side-_20-对象的内部属性-class-是什么" data-v-cb1513f6>20. 对象的内部属性[[Class]]是什么?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_21-什么是-polyfill" class="sidebar-link reco-side-_21-什么是-polyfill" data-v-cb1513f6>21. 什么是 Polyfill ?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_22-javascript-代码中的-use-strict-是什么意思-为什么使用它" class="sidebar-link reco-side-_22-javascript-代码中的-use-strict-是什么意思-为什么使用它" data-v-cb1513f6>22. JavaScript 代码中的&quot;use strict&quot;是什么意思?为什么使用它?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_23-什么是浏览器的同源策略" class="sidebar-link reco-side-_23-什么是浏览器的同源策略" data-v-cb1513f6>23. 什么是浏览器的同源策略?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-for-in和object-keys的区别" class="sidebar-link reco-side-_24-for-in和object-keys的区别" data-v-cb1513f6>24. for..in和Object.keys的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-1-区别" class="sidebar-link reco-side-_24-1-区别" data-v-cb1513f6>24.1 区别：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-2-for-in" class="sidebar-link reco-side-_24-2-for-in" data-v-cb1513f6>24.2 for..in</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-3-object-keys" class="sidebar-link reco-side-_24-3-object-keys" data-v-cb1513f6>24.3 Object.keys</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-4-for-of" class="sidebar-link reco-side-_24-4-for-of" data-v-cb1513f6>24.4 for of</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_24-5-object-entries" class="sidebar-link reco-side-_24-5-object-entries" data-v-cb1513f6>24.5 Object.entries</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-目前主流的js模块化实现的技术有哪些-他们的区别在哪儿" class="sidebar-link reco-side-_25-目前主流的js模块化实现的技术有哪些-他们的区别在哪儿" data-v-cb1513f6>25. 目前主流的js模块化实现的技术有哪些?他们的区别在哪儿?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#简介-4" class="sidebar-link reco-side-简介-4" data-v-cb1513f6>简介</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-1-commonjs" class="sidebar-link reco-side-_25-1-commonjs" data-v-cb1513f6>25.1 CommonJS</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-2-es6模块化" class="sidebar-link reco-side-_25-2-es6模块化" data-v-cb1513f6>25.2 ES6模块化</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-3-amd" class="sidebar-link reco-side-_25-3-amd" data-v-cb1513f6>25.3 AMD</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-4-cmd" class="sidebar-link reco-side-_25-4-cmd" data-v-cb1513f6>25.4 CMD</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_25-5-umd通用模块规范" class="sidebar-link reco-side-_25-5-umd通用模块规范" data-v-cb1513f6>25.5 UMD通用模块规范</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#总结-4" class="sidebar-link reco-side-总结-4" data-v-cb1513f6>总结：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_26-如何解决跨域问题" class="sidebar-link reco-side-_26-如何解决跨域问题" data-v-cb1513f6>26. 如何解决跨域问题?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_27-什么是函数柯里化" class="sidebar-link reco-side-_27-什么是函数柯里化" data-v-cb1513f6>27. 什么是函数柯里化?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#函数柯里化特点" class="sidebar-link reco-side-函数柯里化特点" data-v-cb1513f6>函数柯里化特点：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_28-异步编程的实现方式是什么" class="sidebar-link reco-side-_28-异步编程的实现方式是什么" data-v-cb1513f6>28. 异步编程的实现方式是什么?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_29-说一下import的原理-和require的不同之处在哪儿" class="sidebar-link reco-side-_29-说一下import的原理-和require的不同之处在哪儿" data-v-cb1513f6>29. 说一下import的原理，和require的不同之处在哪儿?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#import原理-实际上就是es6-module的原理" class="sidebar-link reco-side-import原理-实际上就是es6-module的原理" data-v-cb1513f6>import原理(实际上就是ES6 module的原理)</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#import与require区别" class="sidebar-link reco-side-import与require区别" data-v-cb1513f6>import与require区别：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_30-如何理解观察者模式" class="sidebar-link reco-side-_30-如何理解观察者模式" data-v-cb1513f6>30. 如何理解观察者模式</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#定义" class="sidebar-link reco-side-定义" data-v-cb1513f6>定义</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#主要解决的问题" class="sidebar-link reco-side-主要解决的问题" data-v-cb1513f6>主要解决的问题</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#优点" class="sidebar-link reco-side-优点" data-v-cb1513f6>优点</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#缺点" class="sidebar-link reco-side-缺点" data-v-cb1513f6>缺点</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_31-symbol-值的强制类型转换" class="sidebar-link reco-side-_31-symbol-值的强制类型转换" data-v-cb1513f6>31. Symbol 值的强制类型转换?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_32-说一下你理解的-https-中间人攻击" class="sidebar-link reco-side-_32-说一下你理解的-https-中间人攻击" data-v-cb1513f6>32. 说一下你理解的 HTTPS 中间人攻击 ?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#前言" class="sidebar-link reco-side-前言" data-v-cb1513f6>前言：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#中间人攻击过程如下" class="sidebar-link reco-side-中间人攻击过程如下" data-v-cb1513f6>中间人攻击过程如下：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#防范方法" class="sidebar-link reco-side-防范方法" data-v-cb1513f6>防范方法：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_33-判断一个对象是否属于某个类" class="sidebar-link reco-side-_33-判断一个对象是否属于某个类" data-v-cb1513f6>33. 判断一个对象是否属于某个类?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_34-什么是dom和bom" class="sidebar-link reco-side-_34-什么是dom和bom" data-v-cb1513f6>34. 什么是DOM和BOM?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_35-说一下base64的编码方式" class="sidebar-link reco-side-_35-说一下base64的编码方式" data-v-cb1513f6>35. 说一下base64的编码方式</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_36-说一下ajax-axios-fetch三者的区别" class="sidebar-link reco-side-_36-说一下ajax-axios-fetch三者的区别" data-v-cb1513f6>36. 说一下ajax/axios/fetch三者的区别</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_1-ajax" class="sidebar-link reco-side-_1-ajax" data-v-cb1513f6>1. ajax</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_2-axios" class="sidebar-link reco-side-_2-axios" data-v-cb1513f6>2. axios</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-fetch" class="sidebar-link reco-side-_3-fetch" data-v-cb1513f6>3. fetch</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_37-reflect-对象创建目的是什么" class="sidebar-link reco-side-_37-reflect-对象创建目的是什么" data-v-cb1513f6>37. Reflect 对象创建目的是什么?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_38-你所理解的前端路由是什么" class="sidebar-link reco-side-_38-你所理解的前端路由是什么" data-v-cb1513f6>38. 你所理解的前端路由是什么?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_1-基于hash" class="sidebar-link reco-side-_1-基于hash" data-v-cb1513f6>1. 基于hash</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_2-基于history" class="sidebar-link reco-side-_2-基于history" data-v-cb1513f6>2. 基于history</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_39-介绍你所理解的中介者模式" class="sidebar-link reco-side-_39-介绍你所理解的中介者模式" data-v-cb1513f6>39. 介绍你所理解的中介者模式?</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#概念" class="sidebar-link reco-side-概念" data-v-cb1513f6>概念</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#主要解决" class="sidebar-link reco-side-主要解决" data-v-cb1513f6>主要解决</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#应用场景-3" class="sidebar-link reco-side-应用场景-3" data-v-cb1513f6>应用场景</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#优点-2" class="sidebar-link reco-side-优点-2" data-v-cb1513f6>优点</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#缺点-2" class="sidebar-link reco-side-缺点-2" data-v-cb1513f6>缺点</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_40-base64的编码方式" class="sidebar-link reco-side-_40-base64的编码方式" data-v-cb1513f6>40. base64的编码方式？</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#编码原理" class="sidebar-link reco-side-编码原理" data-v-cb1513f6>编码原理：</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#编码解释" class="sidebar-link reco-side-编码解释" data-v-cb1513f6>编码解释：</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_41-require模式引入的查找方式是什么" class="sidebar-link reco-side-_41-require模式引入的查找方式是什么" data-v-cb1513f6>41. require模式引入的查找方式是什么?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_42-面向对象的三要素是什么-分别是什么意思" class="sidebar-link reco-side-_42-面向对象的三要素是什么-分别是什么意思" data-v-cb1513f6>42. 面向对象的三要素是什么，分别是什么意思?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_43-字符串陷阱-请输出结果并进行解释" class="sidebar-link reco-side-_43-字符串陷阱-请输出结果并进行解释" data-v-cb1513f6>43. 字符串陷阱 请输出结果并进行解释</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_44-提升变量-请输出结果并进行解释" class="sidebar-link reco-side-_44-提升变量-请输出结果并进行解释" data-v-cb1513f6>44. 提升变量 请输出结果并进行解释</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_45-添加元素-指定位置添加" class="sidebar-link reco-side-_45-添加元素-指定位置添加" data-v-cb1513f6>45. 添加元素(指定位置添加)</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_1-使用splice方法插入-效率较高" class="sidebar-link reco-side-_1-使用splice方法插入-效率较高" data-v-cb1513f6>1. 使用splice方法插入（效率较高）</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_2-push-apply-splice" class="sidebar-link reco-side-_2-push-apply-splice" data-v-cb1513f6>2. push.apply + splice</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#_3-先复制前0-index个元素-将item元素插入之后-再拼接index之后的元素" class="sidebar-link reco-side-_3-先复制前0-index个元素-将item元素插入之后-再拼接index之后的元素" data-v-cb1513f6>3. 先复制前0~index个元素，将item元素插入之后，再拼接index之后的元素</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_46-filter过滤器-请输出结果并进行解释" class="sidebar-link reco-side-_46-filter过滤器-请输出结果并进行解释" data-v-cb1513f6>46. filter过滤器 请输出结果并进行解释</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_47-优先级顺序-请输出结果并进行解释" class="sidebar-link reco-side-_47-优先级顺序-请输出结果并进行解释" data-v-cb1513f6>47. 优先级顺序 请输出结果并进行解释</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_48-查找数组元素位置" class="sidebar-link reco-side-_48-查找数组元素位置" data-v-cb1513f6>48. 查找数组元素位置</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#方法1" class="sidebar-link reco-side-方法1" data-v-cb1513f6>方法1:</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#方法2" class="sidebar-link reco-side-方法2" data-v-cb1513f6>方法2:</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_49-函数式编程-compose-函数" class="sidebar-link reco-side-_49-函数式编程-compose-函数" data-v-cb1513f6>49. 函数式编程 Compose 函数</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#简介-5" class="sidebar-link reco-side-简介-5" data-v-cb1513f6>简介</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#实现方式" class="sidebar-link reco-side-实现方式" data-v-cb1513f6>实现方式</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_50-发起一个请求到拿到响应-中间经过了0-3s-那么tcp三次握手经历的时间是多少" class="sidebar-link reco-side-_50-发起一个请求到拿到响应-中间经过了0-3s-那么tcp三次握手经历的时间是多少" data-v-cb1513f6>50. 发起一个请求到拿到响应，中间经过了0.3s，那么tcp三次握手经历的时间是多少？</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_51-js为什么要区分微任务和宏任务" class="sidebar-link reco-side-_51-js为什么要区分微任务和宏任务" data-v-cb1513f6>51. JS为什么要区分微任务和宏任务?</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_52-讲一下你所了解的函数式编程" class="sidebar-link reco-side-_52-讲一下你所了解的函数式编程" data-v-cb1513f6>52. 讲一下你所了解的函数式编程</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#理解" class="sidebar-link reco-side-理解" data-v-cb1513f6>理解</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#优点-3" class="sidebar-link reco-side-优点-3" data-v-cb1513f6>优点</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#风险" class="sidebar-link reco-side-风险" data-v-cb1513f6>风险</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_53-手写实现下object-freeze" class="sidebar-link reco-side-_53-手写实现下object-freeze" data-v-cb1513f6>53. 手写实现下Object.freeze</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#介绍" class="sidebar-link reco-side-介绍" data-v-cb1513f6>介绍</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#用法" class="sidebar-link reco-side-用法" data-v-cb1513f6>用法</a></li><li class="level-3" data-v-cb1513f6><a href="/views/interview/iv_js.html#原理模拟实现" class="sidebar-link reco-side-原理模拟实现" data-v-cb1513f6>原理模拟实现</a></li><li class="level-2" data-v-cb1513f6><a href="/views/interview/iv_js.html#_54" class="sidebar-link reco-side-_54" data-v-cb1513f6>54.</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><canvas id="vuepress-canvas-cursor"></canvas><!----></div></div>
    <script src="/assets/js/app.3f3f190d.js" defer></script><script src="/assets/js/3.8deff83d.js" defer></script><script src="/assets/js/1.000d4abb.js" defer></script><script src="/assets/js/38.fce79e18.js" defer></script><script src="/assets/js/13.8fb5847d.js" defer></script>
  </body>
</html>
